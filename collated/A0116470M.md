# A0116470M
###### \Logic\IntegrationTest.java
``` java
package Logic;

import static org.junit.Assert.*;

import java.io.File;
import java.time.LocalDate;
import java.time.LocalTime;

import org.junit.Test;

import Storage.Storage;
import org.apache.commons.io.FileUtils;

public class IntegrationTest {
	Logic obj = Logic.getInstance();

	@Test
	public void testIntegrated1() throws Exception {

		String testString = "";

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(fileLocation), new File(testDir));
			// Storage.getInstance().setCurrentPathName(testDir);
			FileUtils.deleteDirectory(new File(fileLocation));
		} catch (Exception e) {
			e.printStackTrace();
		}

		obj.startExecution();

		testString = "learn python";
		obj.executeCommand(testString);
		assertEquals("learn python", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksToDo().size());

		testString = "e 1 12:00 12/12/2016";
		obj.executeCommand(testString);
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartTime());
		assertEquals("12:00", obj.getScheduledTasksToDo().get(0).getEndTime().toString());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartDate());
		assertEquals("2016-12-12", obj.getScheduledTasksToDo().get(0).getEndDate().toString());

		testString = "undo";
		obj.executeCommand(testString);
		assertEquals("learn python", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getStartTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getEndTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getStartDate());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getEndDate());

		testString = "redo";
		obj.executeCommand(testString);
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartTime());
		assertEquals("12:00", obj.getScheduledTasksToDo().get(0).getEndTime().toString());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartDate());
		assertEquals("2016-12-12", obj.getScheduledTasksToDo().get(0).getEndDate().toString());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksToDo().size());

		testString = "done";
		obj.executeCommand(testString);
		assertEquals("learn python", obj.getScheduledTasksComplete().get(0).getDescription());
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals(1, obj.getScheduledTasksComplete().size());

		testString = "undo";
		obj.startExecution();
		obj.executeCommand(testString);
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());

		testString = "del 1";
		obj.executeCommand(testString);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(testDir), new File(fileLocation));
			FileUtils.deleteDirectory(new File(testDir));
		} catch (Exception e) {
		}
	}

	@Test
	public void testIntegrated2() throws Exception {

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(fileLocation), new File(testDir));
			// Storage.getInstance().setCurrentPathName(testDir);
			FileUtils.deleteDirectory(new File(fileLocation));
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Incorrect Folder Operation");
		}

		obj.startExecution();

		String testString001 = "learn python";
		obj.executeCommand(testString001);
		assertEquals("learn python", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksToDo().size());

		String testString002 = "e 1 12:00 12/12/2016";
		obj.executeCommand(testString002);
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksToDo().size());

		String testString003 = "undo";
		obj.executeCommand(testString003);
		assertEquals("learn python", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksToDo().size());

		String testString004 = "redo";
		obj.executeCommand(testString004);
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartTime());
		assertEquals("12:00", obj.getScheduledTasksToDo().get(0).getEndTime().toString());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartDate());
		assertEquals("2016-12-12", obj.getScheduledTasksToDo().get(0).getEndDate().toString());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksToDo().size());

		String testString005 = "e 31/12/2016 23:59";
		obj.executeCommand(testString005);
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartTime());
		assertEquals("23:59", obj.getScheduledTasksToDo().get(0).getEndTime().toString());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartDate());
		assertEquals("2016-12-31", obj.getScheduledTasksToDo().get(0).getEndDate().toString());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksToDo().size());

		String testString006 = "done 1";
		obj.executeCommand(testString006);
		assertEquals("learn python", obj.getScheduledTasksComplete().get(0).getDescription());
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksComplete().size());

		String testString007 = "home";
		obj.executeCommand(testString007);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(true, obj.getFeedBack().contains("Home Screen Display"));

		String testString008 = "view all";
		obj.executeCommand(testString008);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(1, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString009 = "e 1 12:00 12/12/2016";
		obj.executeCommand(testString009);
		assertEquals(true, obj.getFeedBack().contains("Task number was not found!" + "\n" + "Task was not modified"));
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksComplete().size());

		String testString010 = "undone 1";
		obj.executeCommand(testString010);
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("learn python", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString011 = "del 1";
		obj.executeCommand(testString011);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString012 = "add learn html5 by 23:59 on 31/07/2016";
		obj.executeCommand(testString012);
		assertEquals("learn html5", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("2016-07-31", obj.getScheduledTasksToDo().get(0).getEndDate().toString());
		assertEquals("23:59", obj.getScheduledTasksToDo().get(0).getEndTime().toString());
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString013 = "learn css by 23:59 by 31/08/2016";
		obj.executeCommand(testString013);
		assertEquals("learn css", obj.getScheduledTasksToDo().get(1).getDescription());
		assertEquals("2016-08-31", obj.getScheduledTasksToDo().get(1).getEndDate().toString());
		assertEquals("23:59", obj.getScheduledTasksToDo().get(1).getEndTime().toString());
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString014 = "add learn javascript";
		obj.executeCommand(testString014);
		assertEquals("learn javascript", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString015 = "a learn php";
		obj.executeCommand(testString015);
		assertEquals("learn php", obj.getFloatingTasksToDo().get(1).getDescription());
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString016 = "add learn bootstrap by 23:59 on 31/09/2016";
		obj.executeCommand(testString016);
		assertEquals("2016-09-30", obj.getScheduledTasksToDo().get(2).getEndDate().toString());
		assertEquals("23:59", obj.getScheduledTasksToDo().get(2).getEndTime().toString());
		assertEquals(3, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		String testString017 = "del 1-6";
		obj.executeCommand(testString017);
		assertEquals(3, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals(true, obj.getFeedBack().contains("Task number was not found!"));

		String testString018 = "done 1-6";
		obj.executeCommand(testString018);
		assertEquals(3, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals(true, obj.getFeedBack().contains("Task number was not found!"));

		String testString019 = "undone 1-6";
		obj.executeCommand(testString019);
		assertEquals(3, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals(true, obj.getFeedBack().contains("Invalid Undone Operation!"));

		String testString020 = "done 1-3";
		obj.executeCommand(testString020);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(3, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("learn bootstrap", obj.getScheduledTasksComplete().get(0).getDescription());
		assertEquals("learn css", obj.getScheduledTasksComplete().get(1).getDescription());
		assertEquals("learn html5", obj.getScheduledTasksComplete().get(2).getDescription());

		String testString021 = "del 1-2";
		obj.executeCommand(testString021);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(3, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("learn bootstrap", obj.getScheduledTasksComplete().get(0).getDescription());
		assertEquals("learn css", obj.getScheduledTasksComplete().get(1).getDescription());
		assertEquals("learn html5", obj.getScheduledTasksComplete().get(2).getDescription());

		String testString022 = "redo";
		obj.executeCommand(testString022);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(3, obj.getScheduledTasksComplete().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals(true, obj.getFeedBack().contains("Invalid Redo!"));

		String testString023 = "undo";
		obj.executeCommand(testString023);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(3, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("learn bootstrap", obj.getScheduledTasksComplete().get(0).getDescription());
		assertEquals("learn css", obj.getScheduledTasksComplete().get(1).getDescription());
		assertEquals("learn html5", obj.getScheduledTasksComplete().get(2).getDescription());
		assertEquals("learn javascript", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals("learn php", obj.getFloatingTasksToDo().get(1).getDescription());

		String testString024 = "undone 3,5";
		obj.executeCommand(testString024);
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(1, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("learn html5", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("learn bootstrap", obj.getScheduledTasksToDo().get(1).getDescription());
		assertEquals("learn css", obj.getScheduledTasksComplete().get(0).getDescription());
		assertEquals("learn javascript", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals("learn php", obj.getFloatingTasksToDo().get(1).getDescription());

		String testString025 = "HeLp";
		obj.executeCommand(testString025);
		assertEquals(true, obj.getFeedBack().contains("Help sheet activated"));

		String testString026 = "edit 13 ajax";
		obj.executeCommand(testString026);
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(1, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("learn html5", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("learn bootstrap", obj.getScheduledTasksToDo().get(1).getDescription());
		assertEquals("learn css", obj.getScheduledTasksComplete().get(0).getDescription());
		assertEquals("learn javascript", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals("learn php", obj.getFloatingTasksToDo().get(1).getDescription());

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(testDir), new File(fileLocation));
			FileUtils.deleteDirectory(new File(testDir));
		} catch (Exception e) {
		}
	}

	// @@Author A0132778W
	/**
	 * Software Integrated boundary testing
	 */
	@Test
	public void testIntegrated3() {

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(fileLocation), new File(testDir));
			// Storage.getInstance().setCurrentPathName(testDir);
			FileUtils.deleteDirectory(new File(fileLocation));
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Incorrect Folder Operation");
		}

		obj.startExecution();

		obj.executeCommand("Watch day after .tmr");
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("Watch day after tmr", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getStartTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getEndTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getStartDate());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getEndDate());

		obj.executeCommand("Watch day after .tmr day aftr tmrw");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("Watch day after tmr", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartTime());
		assertEquals(LocalTime.MAX, obj.getScheduledTasksToDo().get(0).getEndTime());
		assertEquals(null, obj.getScheduledTasksToDo().get(0).getStartDate());
		assertEquals(LocalDate.now().plusDays(2), obj.getScheduledTasksToDo().get(0).getEndDate());

		obj.executeCommand("Class     tdy at   0130");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("Class", obj.getScheduledTasksOverDue().get(0).getDescription());
		assertEquals(null, obj.getScheduledTasksOverDue().get(0).getStartTime());
		assertEquals(LocalTime.of(1, 30), obj.getScheduledTasksOverDue().get(0).getEndTime());
		assertEquals(null, obj.getScheduledTasksOverDue().get(0).getStartDate());
		assertEquals(LocalDate.now(), obj.getScheduledTasksOverDue().get(0).getEndDate());

		// $1500 should not be detected as time.
		// Goes to FLoating Task List.
		obj.executeCommand("Save $1500");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("Save $1500", obj.getFloatingTasksToDo().get(1).getDescription());
		assertEquals(null, obj.getFloatingTasksToDo().get(1).getStartTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(1).getEndTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(1).getStartDate());
		assertEquals(null, obj.getFloatingTasksToDo().get(1).getEndDate());

		obj.executeCommand("12345678");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(3, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("12345678", obj.getFloatingTasksToDo().get(2).getDescription());
		assertEquals(null, obj.getFloatingTasksToDo().get(2).getStartTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(2).getEndTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(2).getStartDate());
		assertEquals(null, obj.getFloatingTasksToDo().get(2).getEndDate());

		// Empty Task Description should not be added
		// Task List size should not change
		obj.executeCommand("add 22dec");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(3, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		// Checking for duplication
		// This task already exists. Should not be added to the List.
		obj.executeCommand("12345678");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(3, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		// Task Indexes greater than number of tasks.
		// SHould not delete any task.
		obj.executeCommand("del 1-100");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(3, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		// Index Number always greater than 0
		// SHould not produce any changes.
		obj.executeCommand("del 0");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(3, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		// edit 12345678 to convert from floating to scheduled
		obj.executeCommand("edit 5 at 1030 on 2may20");
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(2, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());
		assertEquals("12345678", obj.getScheduledTasksToDo().get(1).getDescription());
		assertEquals(null, obj.getScheduledTasksToDo().get(1).getStartTime());
		assertEquals(LocalTime.of(10, 30), obj.getScheduledTasksToDo().get(1).getEndTime());
		assertEquals(null, obj.getScheduledTasksToDo().get(1).getStartDate());
		assertEquals(LocalDate.of(2020, 5, 2), obj.getScheduledTasksToDo().get(1).getEndDate());

		// undo last action
		obj.executeCommand("z");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(3, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		// marking save $1500 and 12345678 as done
		obj.executeCommand("done 5, 4-5");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(2, obj.getFloatingTasksComplete().size());

		// undone an incorrect index
		obj.executeCommand("undone 1-2");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(2, obj.getFloatingTasksComplete().size());

		// undo the done action
		obj.executeCommand("z");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(3, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksComplete().size());

		// redo the previous action
		obj.executeCommand("y");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(2, obj.getFloatingTasksComplete().size());

		// redo again. Should yield nothing as done action was performed
		// before the last undo
		obj.executeCommand("redo");
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(2, obj.getFloatingTasksComplete().size());

		obj.executeCommand("  help Jim Manage   time     in 10 days  at   0830 to 5pm");
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(1, obj.getScheduledTasksOverDue().size());
		assertEquals(0, obj.getScheduledTasksComplete().size());
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(2, obj.getFloatingTasksComplete().size());
		assertEquals("Help Jim Manage time", obj.getScheduledTasksToDo().get(1).getDescription());
		assertEquals(LocalTime.of(8, 30), obj.getScheduledTasksToDo().get(1).getStartTime());
		assertEquals(LocalTime.of(17, 00), obj.getScheduledTasksToDo().get(1).getEndTime());
		assertEquals(LocalDate.now().plusDays(10), obj.getScheduledTasksToDo().get(1).getStartDate());
		assertEquals(LocalDate.now().plusDays(10), obj.getScheduledTasksToDo().get(1).getEndDate());

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(testDir), new File(fileLocation));
			FileUtils.deleteDirectory(new File(testDir));
		} catch (Exception e) {
		}
	}
}
```
###### \Logic\Logic.java
``` java
package Logic;

import java.util.ArrayList;
import java.time.LocalDate;
import java.time.LocalDateTime;

import ScheduleHacks.Task;
import ScheduleHacks.OldCommand;
import ScheduleHacks.OldCommand.COMMAND_TYPE;
import ScheduleHacks.History;
import Parser.CommandParser;
import Parser.Command;
import GUI.BottomBottom;
import GUI.TopLeftPanel;
import GUI.TopRightPanel;
import Storage.Storage;

public class Logic {

	private String feedBack;
	private boolean isSearchCommand;
	private boolean isHomeScreen = true;
	private boolean isHighlightOperation;

	private static Logic logicObject = null;

	private Storage storage = Storage.getInstance();
	private History historyObject = History.getInstance();

	private ArrayList<Task> floatingTasksToDo = new ArrayList<Task>();
	private ArrayList<Task> floatingTasksComplete = new ArrayList<Task>();
	private ArrayList<Task> scheduledTasksToDo = new ArrayList<Task>();
	private ArrayList<Task> scheduledTasksComplete = new ArrayList<Task>();
	private ArrayList<Task> scheduledTasksOverDue = new ArrayList<Task>();
	private ArrayList<Task> trackConflictingTasks = new ArrayList<Task>();
	private Integer recentIndex = -1, recentLocation = -1;
	private Task recentTask = new Task();

	private static final String FEEDBACK_YOUR_COMMAND = "\n\nYour Command: ";
	private static final String FEEDBACK_INVALID_COMMAND = "Invalid Command!";
	private static final String FEEDBACK_INVALID_COMMAND_TYPE = "Invalid command type entered!";
	private static final String FEEDBACK_TASK_ADDED = "Task added successfully";
	private static final String FEEDBACK_DUPLICATE_TASK_FOUND_WHEN_ADDING = "Task entered by user already exists! Task not added!";
	private static final String FEEDBACK_TASK_ADDED_BUT_ENCOUNTERED_CONFLICTS = "Task added successfully but task is conflicting with several existing tasks!";
	private static final String FEEDBACK_TASK_DELETED = "Task Deleted Successfully";
	private static final String FEEDBACK_NON_EXISTENT_TASK_NUM = "Task number was not found!";
	private static final String FEEDBACK_NEGATIVE_TASK_NUM = "Task number entered cannot be 0 or negative!";
	private static final String FEEDBACK_TASK_MODIFIED = "Task Edited Successfully";
	private static final String FEEDBACK_TASK_NOT_MODIFIED = "Task was not modified";
	private static final String FEEDBACK_TASK_MODIFIED_BUT_ENCOUNTERED_CONFLICTS = "Task edited successfully but task is conflicting with several existing tasks!";
	private static final String FEEDBACK_DUPLICATE_TASK_FOUND_WHEN_EDITING = "Modified Task already exists! Task not edited!";
	private static final String FEEDBACK_TASK_COMPLETED = "Task Completed Successfully";
	private static final String FEEDBACK_TASK_INCOMPLETED = "Task Marked Undone Successfully";
	private static final String FEEDBACK_TASK_INCOMPLETED_INVALID = "Invalid Undone Operation!";
	private static final String FEEDBACK_EMPTY_TASK_DESCRIPTION = "Empty Task Description. Adding Unsucessful!";
	private static final String FEEDBACK_UNDO_INVALID = "Invalid Undo!";
	private static final String FEEDBACK_UNDO_VALID = "Last Action Un-Done!";
	private static final String FEEDBACK_REDO_VALID = "Last Action Re-Done!";
	private static final String FEEDBACK_REDO_INVALID = "Invalid Redo!";
	private static final String FEEDBACK_EMPTY_STRING = "";
	private static final String FEEDBACK_SEARCH_VALID = "Search Found";
	private static final String FEEDBACK_SEARCH_INVALID = "Search Not Found";
	private static final String FEEDBACK_HELP_CALLED = "Help sheet activated";

	/****************** CONSTRUCTOR ***********************/
	private Logic() {
	}

	// apply singleton
	public static Logic getInstance() {
		if (logicObject == null) {
			logicObject = new Logic();
		}
		return logicObject;
	}

	/****************** SETTER METHODS ***********************/
	private void setFeedBack(String feedBack) {
		this.feedBack = feedBack;
	}

	private void appendFeedBack(String textToAppend) {
		this.feedBack = this.feedBack.concat(textToAppend);
	}

	private void setScheduledTasksToDo(ArrayList<Task> currentTaskList) {
		scheduledTasksToDo.clear();
		scheduledTasksToDo = currentTaskList;
	}

	private void setScheduledTasksOverDue(ArrayList<Task> currentTaskList) {
		scheduledTasksOverDue.clear();
		scheduledTasksOverDue = currentTaskList;
	}

	private void setScheduledTasksComplete(ArrayList<Task> currentTaskList) {
		scheduledTasksComplete.clear();
		scheduledTasksComplete = currentTaskList;
	}

	private void setFloatingTasksToDo(ArrayList<Task> currentTaskList) {
		floatingTasksToDo.clear();
		floatingTasksToDo = currentTaskList;
	}

	private void setFloatingTasksComplete(ArrayList<Task> currentTaskList) {
		floatingTasksComplete.clear();
		floatingTasksComplete = currentTaskList;
	}

	private void setRecentIndexOfTask(Integer recentIndex) {
		this.recentIndex = recentIndex;
	}

	private void setRecentTaskDetails(Task recentTask) {
		this.recentTask = recentTask;
	}

	private void setRecentLocation(int location) {
		recentLocation = location;
	}

	/****************** GETTER METHODS ***********************/
	public String getFeedBack() {
		return feedBack;
	}

	public ArrayList<Task> getScheduledTasksToDo() {
		return scheduledTasksToDo;
	}

	public ArrayList<Task> getScheduledTasksOverDue() {
		return scheduledTasksOverDue;
	}

	public ArrayList<Task> getScheduledTasksComplete() {
		return scheduledTasksComplete;
	}

	public ArrayList<Task> getFloatingTasksToDo() {
		return floatingTasksToDo;
	}

	public ArrayList<Task> getFloatingTasksComplete() {
		return floatingTasksComplete;
	}

	public Integer getRecentIndexOfTask() {
		return recentIndex;
	}

	public Task getRecentTaskDetails() {
		return recentTask;
	}

	public int getRecentLocation() {
		return recentLocation;
	}

	public boolean isHomeScreen() {
		return isHomeScreen;
	}

	public boolean isHighlightOperation() {
		return isHighlightOperation;
	}

	/****************** OTHER METHODS ***********************/
	/*
	 * this method is called in CLI by logic obj, hence transmitting string
	 * userInput from UI to Logic
	 */
	public void startExecution() {
		try {
			storage.loadToList();
			setFloatingTasksComplete(storage.getFloatingTasksComplete());
			setFloatingTasksToDo(storage.getFloatingTasksToDo());
			setScheduledTasksComplete(storage.getScheduledTasksComplete());
			setScheduledTasksToDo(storage.getScheduledTasksToDo());
			setScheduledTasksOverDue(storage.getScheduledTasksOverDue());
			isHomeScreen = true;
			for (int i = 0; i < scheduledTasksOverDue.size(); i++) {
				addTask(scheduledTasksOverDue.remove(i), true, 0);
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	public void firstRun() {
		isHomeScreen = true;
		ArrayList<Task> firstList = new ArrayList<Task>();
		ArrayList<Integer> indexList = new ArrayList<Integer>();
		firstList = setDueTodayTomorrowList(firstList, indexList);
		TopLeftPanel.firstSet(firstList, indexList);
		indexList = setFloatingIndexList();
		TopRightPanel.firstSet(floatingTasksToDo, indexList);
	}

	public ArrayList<Task> setDueTodayTomorrowList(ArrayList<Task> firstList, ArrayList<Integer> indexList) {
		if (scheduledTasksOverDue != null) {
			for (Task task : scheduledTasksOverDue) {
				if (task.getEndDate().isEqual(LocalDate.now())) {
					firstList.add(task);
					indexList.add(scheduledTasksOverDue.indexOf(task) + 1);
				}
			}
		}

		int count = scheduledTasksOverDue.size() + 1;

		if (scheduledTasksToDo != null) {
			LocalDate tmw = LocalDate.now().plusDays(1);
			for (Task task : scheduledTasksToDo) {
				if (task.getEndDate().isAfter(tmw)) {
					if (task.getStartDate() == null) {
						break;
					}
					if (task.getStartDate().isAfter(tmw)) {
						break;
					}
				}
				firstList.add(task);
				indexList.add(count++);
			}
		}
		return firstList;
	}

	public ArrayList<Integer> setFloatingIndexList() {
		ArrayList<Integer> index = new ArrayList<Integer>();
		int count = scheduledTasksOverDue.size() + scheduledTasksToDo.size();
		for (int i = 1; i <= floatingTasksToDo.size(); i++) {
			index.add(i + count);
		}
		return index;
	}

	/*
	 * calls retrieveParsedCommand, from which private methods are called in
	 * Logic class
	 */
	public void executeCommand(String userInput) {
		try {
			historyObject.addToCommandHistory(userInput);
			historyObject.setIndexCommandHistory();
			retrieveParsedCommand(userInput);
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	/*
	 * this method gets back the parsed Command class from parser. Proceeds to
	 * execute function aft obtaining COMMAND_TYPE and Task classes clears
	 * conflicting tasks index, shifts tasks, whose deadlines have exceeded
	 * current date and time to scheduledOverDue tasks and stores updated
	 * arrayLists into storage class
	 */
	public void retrieveParsedCommand(String originalDescription) {
		try {
			Command.COMMAND_TYPE typeCommand = null;
			Command existingCommand = CommandParser.getParsedCommand(originalDescription);
			typeCommand = getCommand(existingCommand);
			Task getTaskToExecute = getTaskDescription(existingCommand);
			execute(typeCommand, existingCommand, getTaskToExecute);
			appendFeedBack(FEEDBACK_YOUR_COMMAND + originalDescription);
			trackConflictingTasks.clear();
			autoChangeTaskStatus();
			storage.storeToFiles(getFloatingTasksToDo(), getFloatingTasksComplete(), getScheduledTasksToDo(),
					getScheduledTasksComplete(), getScheduledTasksOverDue());
		} catch (Exception e) {
			e.printStackTrace();
			setFeedBack(FEEDBACK_INVALID_COMMAND);
		}
	}

	/*
	 * this method gets the specific command type to be executed such as add,
	 * delete, modify etc
	 */
	public Command.COMMAND_TYPE getCommand(Command existingCommand) {
		Command.COMMAND_TYPE executeCommand = null;
		try {
			executeCommand = existingCommand.getCommandType();
			return executeCommand;
		} catch (Exception e) {
			setFeedBack(FEEDBACK_INVALID_COMMAND_TYPE);
			return null;
		}
	}

	/* this method retrieves all relevant task details from task class */
	public Task getTaskDescription(Command existingCommand) {
		Task executeTask = existingCommand.getTaskDetails();
		return executeTask;
	}

	/*
	 * this method calls the respective execution methods for the respective
	 * command types
	 */
	public void execute(Command.COMMAND_TYPE executeCommand, Command retrievedCommand, Task executeTask) {

		isSearchCommand = false;
		isHomeScreen = false;
		isHighlightOperation = false;

		switch (executeCommand) {
		case ADD_TASK:
			isHighlightOperation = true;
			addTask(executeTask, false, 1);
			historyObject.clearRedoStack();
			break;
		case DELETE_TASK:
			deleteTask(retrievedCommand.getIndexList(), false);
			historyObject.clearRedoStack();
			break;
		case MODIFY_TASK:
			editTask(retrievedCommand.getIndexList(), executeTask.getDescription(), false);
			historyObject.clearRedoStack();
			break;
		case COMPLETE_TASK:
			completeTask(retrievedCommand.getIndexList(), false);
			historyObject.clearRedoStack();
			break;
		case INCOMPLETE_TASK:
			incompleteTask(retrievedCommand.getIndexList(), false);
			historyObject.clearRedoStack();
			break;
		case UNDO_TASK:
			undoTask();
			break;
		case REDO_TASK:
			redoTask();
			break;
		case VIEW_LIST:
			searchTask(executeTask);
			historyObject.clearRedoStack();
			break;
		case SEARCH_TASK:
			searchTask(executeTask);
			historyObject.clearRedoStack();
			break;
		case SET_DIRECTORY:
			setNewDirectoryPath(executeTask);
			historyObject.clearRedoStack();
			break;
		case HOME:
			firstRun();
			setFeedBack("Home Screen Display");
			historyObject.clearRedoStack();
			break;
		case VIEW_ALL:
			setFeedBack(FEEDBACK_EMPTY_STRING);
			historyObject.clearRedoStack();
			break;
		case HELP:
			setHelpInstructions();
			setFeedBack(FEEDBACK_HELP_CALLED);
			historyObject.clearRedoStack();
			break;
		case EXIT:
			exit();
			historyObject.clearRedoStack();
			break;
		}
	}

	public void setNewDirectoryPath(Task executeTask) {
		try {
			storage.setCurrentPathName(executeTask.getDescription());
			setFeedBack("Directory Path Successfully Changed!");
		} catch (Exception e) {
			setFeedBack("Invalid Directory Path!!");
		}
	}

	public void setHelpInstructions() {
		BottomBottom.setHelp();
	}

	/*
	 * adds task based on the startdate, enddate, starttime and endtime for
	 * scheduled tasks into either scheduledtodo or scheduledoverdue arraylist
	 * while floating tasks are auto added into floatingtodo arraylist
	 */
	private int addTask(Task executeTask, boolean isUndoOperation, int setRecentTask) {
		int indexOfTask = -1;

		if (executeTask.isComplete()) {
			if (executeTask.isFloatingTask()) {
				floatingTasksComplete.add(executeTask);
			} else {
				scheduledTasksComplete.add(executeTask);
			}
			return indexOfTask;
		}

		if (executeTask.getDescription() == null || executeTask.getDescription().isEmpty()) {
			isHighlightOperation = false;
			setFeedBack(FEEDBACK_EMPTY_TASK_DESCRIPTION);
			return indexOfTask;
		}
		if (setRecentTask == 1) {
			indexOfTask = duplicationCheckProcedures(executeTask);
			setRecentTaskDetails(executeTask);
			setRecentIndexOfTask(indexOfTask);
		} else if (setRecentTask == 0) {
			indexOfTask = duplicationCheckProcedures(executeTask);
			updateRecentIndexOfTask();
		}

		if (!isUndoOperation && indexOfTask >= 0) {
			ArrayList<Task> taskList = new ArrayList<Task>();
			ArrayList<Integer> indexList = new ArrayList<Integer>();
			taskList.add(executeTask);
			indexList.add(indexOfTask);
			OldCommand recentCommand = new OldCommand(COMMAND_TYPE.ADD_TASK, taskList, indexList);
			historyObject.addToUndoList(recentCommand);
		}
		return indexOfTask;
	}

	/*
	 * checks whether new task being added already exists in scheduledtodo,
	 * scheduledoverdue and floatingtodo methods. If task exists in one of these
	 * 3 arraylists, task is not added. If duplicate is not found, invokes
	 * addTaskInOrder method to get the position to add the new task in its
	 * respective arraylist
	 */
	private int duplicationCheckProcedures(Task currentTask) {
		ArrayList<Boolean> duplicate = new ArrayList<Boolean>();
		boolean checkForDuplication = true;
		// boolean isDuplicate;
		int currentIndexOfTask = -1;

		if (currentTask.isScheduledTask()) {
			LocalDateTime currentTaskEndDateTime = LocalDateTime.of(currentTask.getEndDate(), currentTask.getEndTime());

			if (currentTaskEndDateTime.isBefore(LocalDateTime.now())) {
				checkForDuplication = checkForScheduledDuplication(currentTask, scheduledTasksOverDue);
				duplicate.add(checkForDuplication);
			} else {
				checkForDuplication = checkForScheduledDuplication(currentTask, scheduledTasksToDo);
				duplicate.add(checkForDuplication);
			}
		} else if (currentTask.isFloatingTask()) {
			checkForDuplication = checkForFloatingDuplication(currentTask, floatingTasksToDo);
			duplicate.add(checkForDuplication);
		}

		if (currentTask.isScheduledTask()) {
			if (duplicate.size() == 1) {
				if (duplicate.get(0) == false) {
					currentIndexOfTask = addTaskInOrder(currentTask);
				} else if (duplicate.get(0)) {
					isHighlightOperation = false;
					setFeedBack(FEEDBACK_DUPLICATE_TASK_FOUND_WHEN_ADDING);
				}
			}
		} else if (currentTask.isFloatingTask()) {
			if (duplicate.get(0) == false) {
				floatingTasksToDo.add(currentTask);
				currentIndexOfTask = scheduledTasksOverDue.size() + scheduledTasksToDo.size()
						+ floatingTasksToDo.size();
				setFeedBack(FEEDBACK_TASK_ADDED);
			} else if (duplicate.get(0)) {
				isHighlightOperation = false;
				setFeedBack(FEEDBACK_DUPLICATE_TASK_FOUND_WHEN_ADDING);
			}
		}
		duplicate.clear();
		return currentIndexOfTask;

	}

	/*
	 * it calls standardAddScheduledTaskProcedures method to determine which
	 * position should the scheduledTask be added to. Returns this position to
	 * duplicationCheckProcedures method
	 */
	private int addTaskInOrder(Task executeTask) {
		int position = -1;

		if (LocalDateTime.of(executeTask.getEndDate(), executeTask.getEndTime()).isBefore(LocalDateTime.now())) {
			int result = standardAddScheduledTaskProcedures(scheduledTasksOverDue, executeTask, position);
			position = result;
		} else {
			int result = standardAddScheduledTaskProcedures(scheduledTasksToDo, executeTask, position);
			position = result + scheduledTasksOverDue.size();
		}
		return position + 1;
	}

	/*
	 * gets position to add for scheduled task from sortTaskList method checks
	 * whether scheduled task is overlapping with any other scheduled task in
	 * same scheduled arraylist. if overlapping occurs, appropriate feedback is
	 * set. position for new task to be added passed to addTaskInOrder method
	 */
	private int standardAddScheduledTaskProcedures(ArrayList<Task> scheduledTaskList, Task taskAdd, int positionToAdd) {
		boolean overLapWithTask = true;

		positionToAdd = sortTaskList(scheduledTaskList, taskAdd);
		overLapWithTask = compareWithScheduledTasks(taskAdd, scheduledTaskList);
		scheduledTaskList.add(positionToAdd, taskAdd);
		if (overLapWithTask) {
			if (trackConflictingTasks.size() == 1) {
				setFeedBack(FEEDBACK_TASK_ADDED + " but new task is conflicting with "
						+ trackConflictingTasks.get(0).getDescription());
			} else {
				setFeedBack(FEEDBACK_TASK_ADDED_BUT_ENCOUNTERED_CONFLICTS);
			}
		} else {
			setFeedBack(FEEDBACK_TASK_ADDED);
		}
		return positionToAdd;
	}

	/*
	 * checks whether new task slated for adding is already existing in either
	 * scheduledtodo or scheduledoverdue arraylists. Returns true if duplicate
	 * is found and false if no copy is found.
	 */
	private boolean checkForScheduledDuplication(Task relevantTask, ArrayList<Task> scheduledTasks) {
		for (int i = 0; i < scheduledTasks.size(); i++) {
			int tracker = 0;
			if (relevantTask.getDescription().equals(scheduledTasks.get(i).getDescription())) {
				tracker++;
			}
			if (((relevantTask.getStartDate() != null) && (scheduledTasks.get(i).getStartDate() != null)
					&& (relevantTask.getStartDate().equals(scheduledTasks.get(i).getStartDate())))
					|| (relevantTask.getStartDate() == null) && (scheduledTasks.get(i).getStartDate() == null)) {
				tracker++;
			}
			if (((relevantTask.getStartTime() != null) && (scheduledTasks.get(i).getStartTime() != null)
					&& (relevantTask.getStartTime().equals(scheduledTasks.get(i).getStartTime())))
					|| (relevantTask.getStartTime() == null) && (scheduledTasks.get(i).getStartTime() == null)) {
				tracker++;
			}
			if (relevantTask.getEndDate().equals(scheduledTasks.get(i).getEndDate())) {
				tracker++;
			}
			if (((relevantTask.getEndTime() != null) && (scheduledTasks.get(i).getEndTime() != null)
					&& (relevantTask.getEndTime().equals(scheduledTasks.get(i).getEndTime())))
					|| (relevantTask.getEndTime() == null) && (scheduledTasks.get(i).getEndTime() == null)) {
				tracker++;
			}
			if (tracker == 5) {
				setRecentLocation(i);
				return true;
			}
		}
		return false;
	}

	/*
	 * checks whether new task slated for adding is already existing in
	 * floatingTasksToDo arraylist. Returns true if duplicate is found and false
	 * if no copy is found.
	 */
	private boolean checkForFloatingDuplication(Task relevantTask, ArrayList<Task> floatingTasks) {
		for (int i = 0; i < floatingTasks.size(); i++) {
			if (relevantTask.getDescription().equalsIgnoreCase(floatingTasks.get(i).getDescription())) {
				setRecentLocation(i);
				return true;
			}
		}
		return false;
	}

	/*
	 * checks if new task is conflicting with all the existing tasks in that
	 * particular arraylist in which the new task is going to be added. returns
	 * true if new task is conflicting with any of the existing tasks and false
	 * otherwise and this outcome is passed to standardAddScheduledTask
	 * Procedures method. Invokes noteConflictingTask method to take note of
	 * conflicting tasks' indexes
	 */
	private boolean compareWithScheduledTasks(Task taskForAdd, ArrayList<Task> relevantTaskList) {
		LocalDateTime taskEndDateTime = null, taskStartDateTime = null;
		LocalDateTime relevantTaskEndDateTime = null, relevantTaskStartDateTime = null;
		int trackBlock = 0;

		if (taskForAdd.getEndDate() != null) {
			taskEndDateTime = LocalDateTime.of(taskForAdd.getEndDate(), taskForAdd.getEndTime());
		}
		if (taskForAdd.getStartDate() != null) {
			taskStartDateTime = LocalDateTime.of(taskForAdd.getStartDate(), taskForAdd.getStartTime());
		}

		for (int i = 0; i < relevantTaskList.size(); i++) {
			relevantTaskEndDateTime = LocalDateTime.of(relevantTaskList.get(i).getEndDate(),
					relevantTaskList.get(i).getEndTime());
			relevantTaskStartDateTime = null;
			if (relevantTaskList.get(i).getStartDate() != null) {
				relevantTaskStartDateTime = LocalDateTime.of(relevantTaskList.get(i).getStartDate(),
						relevantTaskList.get(i).getStartTime());
			}

			if (relevantTaskStartDateTime != null) {
				if ((taskStartDateTime != null) && (taskEndDateTime.isAfter(relevantTaskStartDateTime))
						&& (taskStartDateTime.isBefore(relevantTaskEndDateTime))) {
					trackBlock++;
					noteConflictingTask(relevantTaskList.get(i));
				} else if ((taskStartDateTime == null) && (taskEndDateTime.isAfter(relevantTaskStartDateTime))
						&& (taskEndDateTime.isBefore(relevantTaskEndDateTime))) {
					trackBlock++;
					noteConflictingTask(relevantTaskList.get(i));
				}
			} else if (relevantTaskStartDateTime == null) {
				if ((taskStartDateTime != null) && (taskEndDateTime.isAfter(relevantTaskEndDateTime))
						&& (taskStartDateTime.isBefore(relevantTaskEndDateTime))) {
					trackBlock++;
					noteConflictingTask(relevantTaskList.get(i));
				}
			}
		}

		if (trackBlock == 0) {
			return false;
		} else {
			return true;
		}
	}

	/* takes note of the indexes for conflicting tasks */
	private void noteConflictingTask(Task conflict) {
		trackConflictingTasks.add(conflict);
	}

	/*
	 * sorts scheduled tasks to be added based on end date, followed by
	 * startdatetime instance
	 */
	private int sortTaskList(ArrayList<Task> taskList, Task task) {
		LocalDateTime taskDateTime = null;
		if (task.getStartDate() != null) {
			taskDateTime = LocalDateTime.of(task.getStartDate(), task.getStartTime());
		} else {
			taskDateTime = LocalDateTime.of(task.getEndDate(), task.getEndTime());
		}
		int taskPosition = taskList.size();

		for (int i = 0; i < taskList.size(); i++) {
			LocalDateTime selectedTaskDateTime = null;
			if (taskList.get(i).getStartDate() != null) {
				selectedTaskDateTime = LocalDateTime.of(taskList.get(i).getStartDate(), taskList.get(i).getStartTime());
			} else {
				selectedTaskDateTime = LocalDateTime.of(taskList.get(i).getEndDate(), taskList.get(i).getEndTime());
			}

			if (taskDateTime.isBefore(selectedTaskDateTime)) {
				return i;
			} else if (taskDateTime.isEqual(selectedTaskDateTime)) {
				if (LocalDateTime.of(task.getEndDate(), task.getEndTime())
						.isBefore(LocalDateTime.of(taskList.get(i).getEndDate(), taskList.get(i).getEndTime()))) {
					return i;
				}
			}
		}
		return taskPosition;
	}

	/*
	 * deleteTask from scheduledTasksToDo or floatingTasksToDo based on task
	 * number. Multiple tasks can be deleted
	 */
	private void deleteTask(ArrayList<Integer> taskDigit, boolean isUndoOperation) {
		// Creating undo parameter
		ArrayList<Task> taskList = new ArrayList<Task>();
		Task removedTask = null;
		int lastAddedIndex = -1;
		boolean isAborted = false;

		if (taskDigit == null || taskDigit.isEmpty()) {
			taskDigit = new ArrayList<Integer>();
			lastAddedIndex = getRecentIndexOfTask();
			taskDigit.add(lastAddedIndex);
		}
		for (int i = taskDigit.size() - 1; i >= 0; i--) {
			if (taskDigit.get(i) > 0) {
				if (taskDigit.get(i) <= scheduledTasksOverDue.size()) {
					removedTask = scheduledTasksOverDue.remove(taskDigit.get(i) - 1);
					taskList.add(0, removedTask);
					setFeedBack(FEEDBACK_TASK_DELETED);
				} else if (taskDigit.get(i) <= (scheduledTasksOverDue.size() + scheduledTasksToDo.size())) {
					removedTask = scheduledTasksToDo.remove(taskDigit.get(i) - 1 - scheduledTasksOverDue.size());
					taskList.add(0, removedTask);
					setFeedBack(FEEDBACK_TASK_DELETED);

				} else if (taskDigit.get(
						i) <= (scheduledTasksToDo.size() + floatingTasksToDo.size() + scheduledTasksOverDue.size())) {
					removedTask = floatingTasksToDo
							.remove(taskDigit.get(i) - 1 - scheduledTasksToDo.size() - scheduledTasksOverDue.size());
					taskList.add(0, removedTask);
					setFeedBack(FEEDBACK_TASK_DELETED);

				} else if (taskDigit.get(i) <= (scheduledTasksToDo.size() + floatingTasksToDo.size()
						+ scheduledTasksOverDue.size() + scheduledTasksComplete.size())) {

					removedTask = scheduledTasksComplete.remove(taskDigit.get(i) - 1 - scheduledTasksToDo.size()
							- scheduledTasksOverDue.size() - floatingTasksToDo.size());

					taskList.add(0, removedTask);
					setFeedBack(FEEDBACK_TASK_DELETED);
				} else if (taskDigit
						.get(i) <= (scheduledTasksToDo.size() + floatingTasksToDo.size() + scheduledTasksOverDue.size()
								+ scheduledTasksComplete.size() + floatingTasksComplete.size())) {
					removedTask = floatingTasksComplete.remove(taskDigit.get(i) - 1 - scheduledTasksToDo.size()
							- scheduledTasksOverDue.size() - floatingTasksToDo.size() - scheduledTasksComplete.size());
					taskList.add(0, removedTask);
					setFeedBack(FEEDBACK_TASK_DELETED);
				} else {
					isAborted = true;
					setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM);
					break;
				}
			} else {
				isAborted = true;
				setFeedBack(FEEDBACK_NEGATIVE_TASK_NUM);
				break;
			}
		}

		// for undo functionality
		if (!isUndoOperation) {
			OldCommand recentCommand = new OldCommand(COMMAND_TYPE.DELETE_TASK, taskList, taskDigit);
			historyObject.addToUndoList(recentCommand);
		}

		if (isAborted && !isUndoOperation) {
			undoTask();
			setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM);
		}
		updateRecentIndexOfTask();
	}

	/*
	 * this method is invoked by addTask, deleteTask, editTask methods to sort
	 * out the new index of most recent task dealt with by the user. checks all
	 * 5 arraylists and updates index accordingly
	 */
	private void updateRecentIndexOfTask() {
		Task mostRecentTask = getRecentTaskDetails();
		boolean outcome = false;

		if (mostRecentTask.isScheduledTask()) {
			LocalDateTime mostRecentTaskEndDateTime = LocalDateTime.of(mostRecentTask.getEndDate(),
					mostRecentTask.getEndTime());

			if (mostRecentTaskEndDateTime.isBefore(LocalDateTime.now())) {
				outcome = checkForScheduledDuplication(mostRecentTask, scheduledTasksOverDue);
				if (outcome) {
					setRecentIndexOfTask(getRecentLocation() + 1);
					setRecentTaskDetails(scheduledTasksOverDue.get(getRecentLocation()));
				}
			} else {
				outcome = checkForScheduledDuplication(mostRecentTask, scheduledTasksToDo);
				if (outcome) {
					setRecentIndexOfTask(getRecentLocation() + 1 + scheduledTasksOverDue.size());
					setRecentTaskDetails(scheduledTasksToDo.get(getRecentLocation()));
				}
			}
		} else if (mostRecentTask.isFloatingTask()) {
			outcome = checkForFloatingDuplication(mostRecentTask, floatingTasksToDo);
			if (outcome) {
				setRecentIndexOfTask(getRecentLocation() + 1 + scheduledTasksOverDue.size());
				setRecentTaskDetails(floatingTasksToDo.get(getRecentLocation()));
			}
		}
		if (!outcome) {
			if (mostRecentTask.isScheduledTask()) {
				outcome = checkForScheduledDuplication(mostRecentTask, scheduledTasksComplete);
				if (outcome) {
					setRecentIndexOfTask(getRecentLocation() + 1 + scheduledTasksOverDue.size()
							+ scheduledTasksToDo.size() + floatingTasksToDo.size());
					setRecentTaskDetails(scheduledTasksComplete.get(getRecentLocation()));
				}
			} else if (mostRecentTask.isFloatingTask()) {
				outcome = checkForFloatingDuplication(mostRecentTask, floatingTasksComplete);
				if (outcome) {
					setRecentIndexOfTask(getRecentLocation() + 1 + scheduledTasksOverDue.size()
							+ scheduledTasksToDo.size() + floatingTasksToDo.size() + scheduledTasksComplete.size());
					setRecentTaskDetails(floatingTasksComplete.get(getRecentLocation()));
				}
			}
		}
		if (!outcome) {
			setRecentIndexOfTask(-1);
		}
	}

	/*
	 * modifies tasks based on description, startdate, starttime, enddate,
	 * endtime. Tasks to be edited are removed, modified are checked for
	 * duplication before being
	 */
	public void editTask(ArrayList<Integer> indexList, String editInfo, boolean isUndoOperation) {
		Task taskToEdit = null;
		Task taskOriginal = null;
		int indexToEdit = -1;
		boolean duplicatedScheduledOverDue = false, duplicated = false;

		isHighlightOperation = true;

		if (indexList == null || indexList.isEmpty()) {
			indexToEdit = getRecentIndexOfTask();
			indexList = new ArrayList<Integer>();
			indexList.add(indexToEdit);
		} else {
			indexToEdit = indexList.get(0);
		}

		if (indexToEdit > 0) {
			if (indexToEdit <= scheduledTasksOverDue.size()) {
				taskOriginal = scheduledTasksOverDue.get(indexToEdit - 1);
				taskToEdit = scheduledTasksOverDue.remove(indexToEdit - 1);
			} else if (indexToEdit <= scheduledTasksOverDue.size() + scheduledTasksToDo.size()) {
				taskOriginal = scheduledTasksToDo.get(indexToEdit - 1 - scheduledTasksOverDue.size());
				taskToEdit = scheduledTasksToDo.remove(indexToEdit - 1 - scheduledTasksOverDue.size());
			} else if (indexToEdit <= scheduledTasksToDo.size() + floatingTasksToDo.size()
					+ scheduledTasksOverDue.size()) {
				taskOriginal = floatingTasksToDo
						.get(indexToEdit - 1 - scheduledTasksToDo.size() - scheduledTasksOverDue.size());
				taskToEdit = floatingTasksToDo
						.remove(indexToEdit - 1 - scheduledTasksToDo.size() - scheduledTasksOverDue.size());
			} else {
				/*
				 * isHighlightOperation = false;
				 * setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM + "\n");
				 */
				editInfo = indexToEdit + " " + editInfo;
				indexToEdit = getRecentIndexOfTask();
				indexList = new ArrayList<Integer>();
				indexList.add(indexToEdit);
			}
		}

		if (taskToEdit == null) {
			setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM + "\n" + FEEDBACK_TASK_NOT_MODIFIED);
		} else {
			Task editedTask = CommandParser.editExistingTask(taskToEdit, editInfo);
			if (editedTask.isScheduledTask()) {
				LocalDateTime editedTaskEndDateTime = LocalDateTime.of(editedTask.getEndDate(),
						editedTask.getEndTime());

				if (editedTaskEndDateTime.isBefore(LocalDateTime.now())) {
					duplicatedScheduledOverDue = checkForScheduledDuplication(editedTask, scheduledTasksOverDue);
				} else {
					duplicated = checkForScheduledDuplication(editedTask, scheduledTasksToDo);
				}
				if ((duplicatedScheduledOverDue) || (duplicated)) {
					editedTask = taskOriginal;
					isHighlightOperation = false;
					setFeedBack(FEEDBACK_DUPLICATE_TASK_FOUND_WHEN_EDITING);
				}
			} else if (editedTask.isFloatingTask()) {
				duplicated = checkForFloatingDuplication(editedTask, floatingTasksToDo);

				if (duplicated) {
					editedTask = taskOriginal;
					isHighlightOperation = false;
					setFeedBack(FEEDBACK_DUPLICATE_TASK_FOUND_WHEN_EDITING);
				}
			}
			int newIndex = addTask(editedTask, true, 1);

			if ((duplicated) || (duplicatedScheduledOverDue)) {
				setFeedBack(FEEDBACK_DUPLICATE_TASK_FOUND_WHEN_EDITING);
			} else if ((!duplicated) && (!duplicatedScheduledOverDue)) {
				if (getFeedBack().equals(FEEDBACK_TASK_ADDED)) {
					setFeedBack(FEEDBACK_TASK_MODIFIED);
				} else if (trackConflictingTasks.size() == 1) {
					setFeedBack(FEEDBACK_TASK_MODIFIED + " but new task is conflicting with "
							+ trackConflictingTasks.get(0).getDescription());
				} else {
					setFeedBack(FEEDBACK_TASK_MODIFIED_BUT_ENCOUNTERED_CONFLICTS);
				}
			}

			if (!isUndoOperation && newIndex >= 0 && !duplicated) {
				ArrayList<Task> taskList = new ArrayList<Task>();
				taskList.add(taskToEdit);
				taskList.add(editedTask);
				indexList.add(newIndex);
				OldCommand recentCommand = new OldCommand(COMMAND_TYPE.MODIFY_TASK, taskList, indexList);
				historyObject.addToUndoList(recentCommand);
			}
		}
	}

	/*
	 * adds task into the respective completeArrayList and removes that same
	 * task from the ArrayList that it is currently residing in based on task
	 * number entered by user. Multiple tasks can be completed at once
	 */
	private void completeTask(ArrayList<Integer> taskIndex, boolean isUndoOperation) {
		// undo parameter
		ArrayList<Task> taskList = new ArrayList<Task>();
		int indexToComplete = -1;
		boolean isAborted = false;

		if (taskIndex == null || taskIndex.isEmpty()) {
			taskIndex = new ArrayList<Integer>();
			indexToComplete = getRecentIndexOfTask();
			taskIndex.add(indexToComplete);
		}
		for (int i = taskIndex.size() - 1; i >= 0; i--) {
			int taskToComplete = taskIndex.get(i) - 1;
			if (taskToComplete >= 0) {
				if (taskToComplete < scheduledTasksOverDue.size()) {
					Task completedTask = markAsComplete(scheduledTasksOverDue, scheduledTasksComplete, taskToComplete);
					taskList.add(0, completedTask);
				} else if (taskToComplete < (scheduledTasksToDo.size() + scheduledTasksOverDue.size())) {
					taskToComplete = taskToComplete - (scheduledTasksOverDue.size());
					Task completedTask = markAsComplete(scheduledTasksToDo, scheduledTasksComplete, taskToComplete);
					taskList.add(0, completedTask);
				} else if (taskToComplete < (scheduledTasksOverDue.size() + scheduledTasksToDo.size()
						+ floatingTasksToDo.size())) {
					taskToComplete = taskToComplete - (scheduledTasksToDo.size() + scheduledTasksOverDue.size());
					Task completedTask = markAsComplete(floatingTasksToDo, floatingTasksComplete, taskToComplete);
					taskList.add(0, completedTask);
				} else {
					isAborted = true;
					setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM);
					break;
				}
			} else {
				isAborted = true;
				setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM);
				break;
			}
		}

		if (!isUndoOperation) {
			// for undo functionality
			OldCommand recentCommand = new OldCommand(COMMAND_TYPE.COMPLETE_TASK, taskList, taskIndex);
			historyObject.addToUndoList(recentCommand);
		}

		if (isAborted) {
			undoTask();
			setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM);
		}
		updateRecentIndexOfTask();
	}

	public Task markAsComplete(ArrayList<Task> incompleteList, ArrayList<Task> completeList, int taskNum) {
		Task completeTask = incompleteList.remove(taskNum);
		completeTask.setAsComplete();
		completeList.add(completeTask);
		setFeedBack(FEEDBACK_TASK_COMPLETED);
		return completeTask;
	}

	/*
	 * Tasks to incomplete are moved from their counterpart completed arraylists
	 * to the relevant incomplete arraylists. Multiple tasks can be incompleted
	 * at once
	 */
	public void incompleteTask(ArrayList<Integer> indexList, boolean isUndoOperation) {
		// undo parameter
		ArrayList<Task> taskList = new ArrayList<Task>();

		boolean isAborted = false;

		int minIndex = scheduledTasksOverDue.size() + scheduledTasksToDo.size() + floatingTasksToDo.size() + 1;
		int maxIndex = minIndex + scheduledTasksComplete.size() + floatingTasksComplete.size() - 1;

		if (indexList == null || indexList.isEmpty()) {
			indexList = new ArrayList<Integer>();
			int indexToIncomplete = getRecentIndexOfTask();
			indexList.add(indexToIncomplete);
		}
		if (indexList != null && !indexList.isEmpty()) {
			for (int index = indexList.size() - 1; index >= 0; index--) {
				if (indexList.get(index) == getRecentIndexOfTask()) {
					setRecentIndexOfTask(-1);
				}
				if ((indexList.get(index) >= minIndex) && (indexList.get(index) <= maxIndex)) {
					if (indexList.get(index) < (minIndex + scheduledTasksComplete.size())) {
						Task taskToMark = scheduledTasksComplete.remove(indexList.get(index) - minIndex);
						taskToMark.setAsIncomplete();
						addTask(taskToMark, true, 0);
						taskList.add(0, taskToMark);
					} else {
						Task taskToMark = floatingTasksComplete
								.remove(indexList.get(index) - minIndex - scheduledTasksComplete.size());
						taskToMark.setAsIncomplete();
						addTask(taskToMark, true, 0);
						taskList.add(0, taskToMark);
					}
					setFeedBack(FEEDBACK_TASK_INCOMPLETED);
				} else {
					isAborted = true;
					setFeedBack(FEEDBACK_TASK_INCOMPLETED_INVALID);
					break;
				}
			}
			if (!isUndoOperation) {
				// for undo functionality
				OldCommand recentCommand = new OldCommand(COMMAND_TYPE.INCOMPLETE_TASK, taskList, indexList);
				historyObject.addToUndoList(recentCommand);
			}

			if (isAborted) {
				undoTask();
				setFeedBack(FEEDBACK_TASK_INCOMPLETED_INVALID);
			}
		}
	}

	/* set task as complete */
	public void markTaskComplete(Task task) {
		task.setAsComplete();
		if (task.isFloatingTask()) {
			floatingTasksToDo.remove(task);
			floatingTasksComplete.add(task);
		} else if (task.isScheduledTask()) {
			scheduledTasksOverDue.remove(task);
			scheduledTasksToDo.remove(task);
			scheduledTasksComplete.add(task);
		}
	}

	/* set task as incomplete */
	public void markTaskIncomplete(Task task) {
		task.setAsIncomplete();
		// System.out.println(task.getDescription());
		if (task.isFloatingTask()) {
			floatingTasksComplete.remove(task);
			addTask(task, true, 0);
		} else if (task.isScheduledTask()) {
			scheduledTasksComplete.remove(task);
			addTask(task, true, 0);
		}
	}

	/*
	 * This method automatically shifts scheduledtaskstodo to
	 * scheduledtasksoverdue when date and time has exceeded due date and due
	 * time specified for scheduled task
	 */
	private void autoChangeTaskStatus() {
		LocalDateTime presentDateTime = LocalDateTime.now();

		for (int i = 0; i < scheduledTasksToDo.size(); i++) {
			LocalDateTime scheduledEndDateTime = LocalDateTime.of(scheduledTasksToDo.get(i).getEndDate(),
					scheduledTasksToDo.get(i).getEndTime());

			if ((scheduledEndDateTime.compareTo(presentDateTime)) < 0) {
				changeStatusToOverdue(i);
			}
		}
	}

	/* moves overdue task from scheduledtodo to scheduledoverdue */
	private void changeStatusToOverdue(int i) {
		scheduledTasksOverDue.add(scheduledTasksToDo.get(i));
		setFeedBack("Task " + scheduledTasksToDo.get(i).getDescription() + " has exceeded deadline");
		scheduledTasksToDo.remove(i);
	}

```
###### \Logic\LogicTest.java
``` java
package Logic;

import static org.junit.Assert.*;

import java.io.File;
import java.time.LocalDate;

import org.junit.Test;

import Parser.Command;
import Parser.Command.COMMAND_TYPE;
import Parser.CommandParser;
import ScheduleHacks.Task;

import Storage.Storage;
import org.apache.commons.io.FileUtils;

public class LogicTest {

	Logic obj = Logic.getInstance();

	@Test
	public void testLogic() throws Exception {

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(fileLocation), new File(testDir));
			// Storage.getInstance().setCurrentPathName(testDir);
			FileUtils.deleteDirectory(new File(fileLocation));
		} catch (Exception e) {
			e.printStackTrace();
		}

		String testString = "add study for mid-term 1600 1700 04 apr 16";
		Command existingCommand = CommandParser.getParsedCommand(testString);
		COMMAND_TYPE typeCommand = obj.getCommand(existingCommand);
		Task executeTask = obj.getTaskDescription(existingCommand);
		obj.execute(typeCommand, existingCommand, executeTask);
		assertEquals(false, executeTask.isFloatingTask());
		assertEquals(true, executeTask.isScheduledTask());
		assertEquals("study for mid-term", executeTask.getDescription());
		assertEquals("16:00", executeTask.getStartTime().toString());
		assertEquals("17:00", executeTask.getEndTime().toString());
		assertEquals("2016-04-04", executeTask.getStartDate().toString());
		assertEquals("2016-04-04", executeTask.getEndDate().toString());

		String testString2 = "cs2103 test cases today 2300";
		Command existingCommand2 = CommandParser.getParsedCommand(testString2);
		COMMAND_TYPE typeCommand2 = obj.getCommand(existingCommand2);
		Task executeTask2 = obj.getTaskDescription(existingCommand2);
		obj.execute(typeCommand2, existingCommand2, executeTask2);
		assertEquals(false, executeTask2.isFloatingTask());
		assertEquals(true, executeTask2.isScheduledTask());
		assertEquals("cs2103 test cases", executeTask2.getDescription());
		assertEquals(null, executeTask2.getStartTime());
		assertEquals("23:00", executeTask2.getEndTime().toString());
		assertEquals(null, executeTask2.getStartDate());
		assertEquals(LocalDate.now(), executeTask2.getEndDate());

		String testString3 = "cycle tmr 1600 1800";
		Command existingCommand3 = CommandParser.getParsedCommand(testString3);
		COMMAND_TYPE typeCommand3 = obj.getCommand(existingCommand3);
		Task executeTask3 = obj.getTaskDescription(existingCommand3);
		obj.execute(typeCommand3, existingCommand3, executeTask3);
		assertEquals(false, executeTask3.isFloatingTask());
		assertEquals(true, executeTask3.isScheduledTask());
		assertEquals("cycle", executeTask3.getDescription());
		assertEquals("16:00", executeTask3.getStartTime().toString());
		assertEquals("18:00", executeTask3.getEndTime().toString());
		assertEquals(LocalDate.now().plusDays(1), executeTask3.getStartDate());
		assertEquals(LocalDate.now().plusDays(1), executeTask3.getEndDate());

		String testString4 = "dance lessons tmr 1700 1830";
		Command existingCommand4 = CommandParser.getParsedCommand(testString4);
		COMMAND_TYPE typeCommand4 = obj.getCommand(existingCommand4);
		Task executeTask4 = obj.getTaskDescription(existingCommand4);
		obj.execute(typeCommand4, existingCommand4, executeTask4);
		assertEquals(false, executeTask4.isFloatingTask());
		assertEquals(true, executeTask4.isScheduledTask());
		assertEquals("dance lessons", executeTask4.getDescription());
		assertEquals("17:00", executeTask4.getStartTime().toString());
		assertEquals("18:30", executeTask4.getEndTime().toString());
		assertEquals(LocalDate.now().plusDays(1), executeTask4.getStartDate());
		assertEquals(LocalDate.now().plusDays(1), executeTask4.getEndDate());
		assertEquals("Task added successfully but new task is conflicting with cycle", obj.getFeedBack());

		String testString5 = "cycle tmr 1600 1800";
		Command existingCommand5 = CommandParser.getParsedCommand(testString5);
		COMMAND_TYPE typeCommand5 = obj.getCommand(existingCommand5);
		Task executeTask5 = obj.getTaskDescription(existingCommand5);
		obj.execute(typeCommand5, existingCommand5, executeTask5);
		assertEquals(false, executeTask5.isFloatingTask());
		assertEquals(true, executeTask5.isScheduledTask());
		assertEquals(3, obj.getScheduledTasksToDo().size());
		assertEquals("Task entered by user already exists! Task not added!", obj.getFeedBack());

		String testString05 = "swim tmr 1630-1730";
		Command existingCommand05 = CommandParser.getParsedCommand(testString05);
		COMMAND_TYPE typeCommand05 = obj.getCommand(existingCommand05);
		Task executeTask05 = obj.getTaskDescription(existingCommand05);
		obj.execute(typeCommand05, existingCommand05, executeTask05);
		assertEquals(false, executeTask05.isFloatingTask());
		assertEquals(true, executeTask05.isScheduledTask());
		assertEquals("swim", executeTask05.getDescription());
		assertEquals("16:30", executeTask05.getStartTime().toString());
		assertEquals("17:30", executeTask05.getEndTime().toString());
		assertEquals(LocalDate.now().plusDays(1), executeTask05.getStartDate());
		assertEquals(LocalDate.now().plusDays(1), executeTask05.getEndDate());
		assertEquals("Task added successfully but task is conflicting with several existing tasks!", obj.getFeedBack());

		String testString6 = "del";
		Command existingCommand6 = CommandParser.getParsedCommand(testString6);
		COMMAND_TYPE typeCommand6 = obj.getCommand(existingCommand6);
		Task executeTask6 = obj.getTaskDescription(existingCommand6);
		obj.execute(typeCommand6, existingCommand6, executeTask6);
		assertEquals(obj.getScheduledTasksToDo().size(), 3);
		assertEquals("cs2103 test cases", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("cycle", obj.getScheduledTasksToDo().get(1).getDescription());
		assertEquals("dance lessons", obj.getScheduledTasksToDo().get(2).getDescription());

		String testString7 = "del 1,4";
		Command existingCommand7 = CommandParser.getParsedCommand(testString7);
		COMMAND_TYPE typeCommand7 = obj.getCommand(existingCommand7);
		Task executeTask7 = obj.getTaskDescription(existingCommand7);
		obj.execute(typeCommand7, existingCommand7, executeTask7);
		assertEquals(2, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksOverDue().size());
		assertEquals("cs2103 test cases", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("cycle", obj.getScheduledTasksToDo().get(1).getDescription());

		String testString8 = "edit 1 dogfood app 2200 on 30 apr";
		Command existingCommand8 = CommandParser.getParsedCommand(testString8);
		COMMAND_TYPE typeCommand8 = obj.getCommand(existingCommand8);
		Task executeTask8 = obj.getTaskDescription(existingCommand8);
		obj.execute(typeCommand8, existingCommand8, executeTask8);
		assertEquals("dogfood app", obj.getScheduledTasksToDo().get(1).getDescription());
		assertEquals(LocalDate.of(2016, 4, 30), obj.getScheduledTasksToDo().get(1).getEndDate());
		assertEquals("22:00", obj.getScheduledTasksToDo().get(1).getEndTime().toString());

		String testString9 = "e tmr 1900 2100";
		Command existingCommand9 = CommandParser.getParsedCommand(testString9);
		COMMAND_TYPE typeCommand9 = obj.getCommand(existingCommand9);
		Task executeTask9 = obj.getTaskDescription(existingCommand9);
		obj.execute(typeCommand9, existingCommand9, executeTask9);
		assertEquals(LocalDate.now().plusDays(1), obj.getScheduledTasksToDo().get(1).getEndDate());
		assertEquals("19:00", obj.getScheduledTasksToDo().get(1).getStartTime().toString());
		assertEquals("21:00", obj.getScheduledTasksToDo().get(1).getEndTime().toString());

		String testString10 = "e delete date";
		Command existingCommand10 = CommandParser.getParsedCommand(testString10);
		COMMAND_TYPE typeCommand10 = obj.getCommand(existingCommand10);
		Task executeTask10 = obj.getTaskDescription(existingCommand10);
		obj.execute(typeCommand10, existingCommand10, executeTask10);
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals("dogfood app", obj.getFloatingTasksToDo().get(0).getDescription());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getEndDate());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getStartTime());
		assertEquals(null, obj.getFloatingTasksToDo().get(0).getEndTime());
		assertEquals(true, obj.getFloatingTasksToDo().get(0).isFloatingTask());

		String testString11 = "done";
		Command existingCommand11 = CommandParser.getParsedCommand(testString11);
		COMMAND_TYPE typeCommand11 = obj.getCommand(existingCommand11);
		Task executeTask11 = obj.getTaskDescription(existingCommand11);
		obj.execute(typeCommand11, existingCommand11, executeTask11);
		assertEquals(1, obj.getFloatingTasksComplete().size());
		assertEquals("dogfood app", obj.getFloatingTasksComplete().get(0).getDescription());

		String testString12 = "done 1";
		Command existingCommand12 = CommandParser.getParsedCommand(testString12);
		COMMAND_TYPE typeCommand12 = obj.getCommand(existingCommand12);
		Task executeTask12 = obj.getTaskDescription(existingCommand12);
		obj.execute(typeCommand12, existingCommand12, executeTask12);
		assertEquals(1, obj.getScheduledTasksComplete().size());
		assertEquals("cycle", obj.getScheduledTasksComplete().get(0).getDescription());

		String testString13 = "undone";
		Command existingCommand13 = CommandParser.getParsedCommand(testString13);
		COMMAND_TYPE typeCommand13 = obj.getCommand(existingCommand13);
		Task executeTask13 = obj.getTaskDescription(existingCommand13);
		obj.execute(typeCommand13, existingCommand13, executeTask13);
		assertEquals(1, obj.getFloatingTasksToDo().size());
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals("dogfood app", obj.getFloatingTasksToDo().get(0).getDescription());

		String testString14 = "undone 2";
		Command existingCommand14 = CommandParser.getParsedCommand(testString14);
		COMMAND_TYPE typeCommand14 = obj.getCommand(existingCommand14);
		Task executeTask14 = obj.getTaskDescription(existingCommand14);
		obj.execute(typeCommand14, existingCommand14, executeTask14);
		assertEquals(1, obj.getScheduledTasksToDo().size());

		String testString15 = "undo";
		Command existingCommand15 = CommandParser.getParsedCommand(testString15);
		COMMAND_TYPE typeCommand15 = obj.getCommand(existingCommand15);
		Task executeTask15 = obj.getTaskDescription(existingCommand15);
		obj.execute(typeCommand15, existingCommand15, executeTask15);
		assertEquals(1, obj.getScheduledTasksComplete().size());

		String testString16 = "redo";
		Command existingCommand16 = CommandParser.getParsedCommand(testString16);
		COMMAND_TYPE typeCommand16 = obj.getCommand(existingCommand16);
		Task executeTask16 = obj.getTaskDescription(existingCommand16);
		obj.execute(typeCommand16, existingCommand16, executeTask16);
		assertEquals(1, obj.getScheduledTasksToDo().size());

		String testString17 = "redo";
		Command existingCommand17 = CommandParser.getParsedCommand(testString17);
		COMMAND_TYPE typeCommand17 = obj.getCommand(existingCommand17);
		Task executeTask17 = obj.getTaskDescription(existingCommand17);
		obj.execute(typeCommand17, existingCommand17, executeTask17);
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("Invalid Redo!", obj.getFeedBack());

		String testString18 = "undo";
		Command existingCommand18 = CommandParser.getParsedCommand(testString18);
		COMMAND_TYPE typeCommand18 = obj.getCommand(existingCommand18);
		Task executeTask18 = obj.getTaskDescription(existingCommand18);
		obj.execute(typeCommand18, existingCommand18, executeTask18);
		assertEquals(1, obj.getScheduledTasksComplete().size());

		String testString19 = "e 04/05/2016";
		Command existingCommand19 = CommandParser.getParsedCommand(testString19);
		COMMAND_TYPE typeCommand19 = obj.getCommand(existingCommand19);
		Task executeTask19 = obj.getTaskDescription(existingCommand19);
		obj.execute(typeCommand19, existingCommand19, executeTask19);
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("2016-05-04", obj.getScheduledTasksToDo().get(0).getEndDate().toString());

		String testString20 = "del 1-2";
		Command existingCommand20 = CommandParser.getParsedCommand(testString20);
		COMMAND_TYPE typeCommand20 = obj.getCommand(existingCommand20);
		Task executeTask20 = obj.getTaskDescription(existingCommand20);
		obj.execute(typeCommand20, existingCommand20, executeTask20);
		assertEquals(0, obj.getScheduledTasksToDo().size());
		assertEquals(0, obj.getFloatingTasksToDo().size());
		assertEquals("Task Deleted Successfully", obj.getFeedBack());

		String testString21 = "go for XMen Apocalypse 01/05/2016";
		Command existingCommand21 = CommandParser.getParsedCommand(testString21);
		COMMAND_TYPE typeCommand21 = obj.getCommand(existingCommand21);
		Task executeTask21 = obj.getTaskDescription(existingCommand21);
		obj.execute(typeCommand21, existingCommand21, executeTask21);
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("go for XMen Apocalypse", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("2016-05-01", obj.getScheduledTasksToDo().get(0).getEndDate().toString());

		String testString22 = "home";
		Command existingCommand22 = CommandParser.getParsedCommand(testString22);
		COMMAND_TYPE typeCommand22 = obj.getCommand(existingCommand22);
		Task executeTask22 = obj.getTaskDescription(existingCommand22);
		obj.execute(typeCommand22, existingCommand22, executeTask22);
		assertEquals("Home Screen Display", obj.getFeedBack());
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("go for XMen Apocalypse", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("2016-05-01", obj.getScheduledTasksToDo().get(0).getEndDate().toString());

		String testString23 = "view all";
		Command existingCommand23 = CommandParser.getParsedCommand(testString23);
		COMMAND_TYPE typeCommand23 = obj.getCommand(existingCommand23);
		Task executeTask23 = obj.getTaskDescription(existingCommand23);
		obj.execute(typeCommand23, existingCommand23, executeTask23);
		assertEquals("", obj.getFeedBack());
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("go for XMen Apocalypse", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("2016-05-01", obj.getScheduledTasksToDo().get(0).getEndDate().toString());

		String testString24 = "help";
		Command existingCommand24 = CommandParser.getParsedCommand(testString24);
		COMMAND_TYPE typeCommand24 = obj.getCommand(existingCommand24);
		Task executeTask24 = obj.getTaskDescription(existingCommand24);
		obj.execute(typeCommand24, existingCommand24, executeTask24);
		assertEquals("Help sheet activated", obj.getFeedBack());
		assertEquals(1, obj.getScheduledTasksToDo().size());
		assertEquals("go for XMen Apocalypse", obj.getScheduledTasksToDo().get(0).getDescription());
		assertEquals("2016-05-01", obj.getScheduledTasksToDo().get(0).getEndDate().toString());

		try {
			String testDir = "Test";
			String fileLocation = Storage.getCurrentPathName();
			FileUtils.copyDirectory(new File(testDir), new File(fileLocation));
			FileUtils.deleteDirectory(new File(testDir));
		} catch (Exception e) {
		}
	}
}
```
