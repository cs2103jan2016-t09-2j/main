# A0132778W
###### \GUI\BottomBottom.java
``` java

/**
 * This class runs every minute to ensure that tasks are always transferred to
 * Overdue List as and when needed.
 */
class Refresh {
	Refresh() {
		Logic logicObj = Logic.getInstance();
		logicObj.refresh();
		if (!logicObj.isHomeScreen() && !logicObj.hasSearchList()) {
			// normal display
			ArrayList<Task> OList = new ArrayList<Task>(logicObj.getScheduledTasksOverDue());
			ArrayList<Task> SList = new ArrayList<Task>(logicObj.getScheduledTasksToDo());
			ArrayList<Task> FList = new ArrayList<Task>(logicObj.getFloatingTasksToDo());
			TopLeftPanel.clearText();
			TopLeftPanel.setText(OList, SList, null);
			TopRightPanel.clearText();
			TopRightPanel.setText(FList, null, OList.size() + SList.size());
		}
	}
}
```
###### \GUI\Main_UI.java
``` java

/**
 * This class regularly checks which component of the JFrame has the focus and
 * places a border around it.
 */
class TabFlow extends TimerTask {
	Color prevColor = null;
	JComponent prevFocus = null;
	JComponent thisFocus = null;

	public void run() {
		thisFocus = (JComponent) Main_UI.getFrame().getFocusOwner();
		if (thisFocus != null) {
			if (prevFocus == null || !thisFocus.equals(prevFocus)) {
				if (prevFocus != null) {
					prevFocus.setBackground(prevColor);
				}
				// keeps track of the previous component.
				prevColor = thisFocus.getBackground();
				prevFocus = thisFocus;
				thisFocus.setBackground(new Color(255, 255, 224));
			}
		}
	}
}
```
###### \Logic\Logic.java
``` java
	/**
	 * Reverts back the previous action performed by the user.
	 */
	public void undoTask() {
		try {
			OldCommand toUndo = historyObject.getFromUndoList();
			OldCommand.COMMAND_TYPE cmdType = toUndo.getCommandType();

			switch (cmdType) {
			case ADD_TASK:
				addTaskList(toUndo.getTaskList());
				break;
			case DELETE_TASK:
				deleteTask(toUndo.getIndexList(), true);
				break;
			case COMPLETE_TASK:
				markAsCompleteListUndoOp(toUndo.getTaskList(), toUndo.getIndexList());
				break;
			case INCOMPLETE_TASK:
				markAsIncompleteListUndoOp(toUndo.getTaskList(), toUndo.getIndexList());
				break;
			case MODIFY_TASK:
				/*
				 * For modify the Task list contains two tasks. The first one is
				 * the oldTask and the second one is the newTask. Delete new,
				 * add old.
				 */
				deleteSingleTask(toUndo.getIndexList().get(1));
				addTask(toUndo.getTaskList().get(0), true, 1);
				break;
			default:
				// go back to original home screen
				// incomplete
			}
			setFeedBack(FEEDBACK_UNDO_VALID);
		} catch (Exception e) {
			setFeedBack(FEEDBACK_UNDO_INVALID);
		}
	}

	/**
	 * This method is used to revert the previous undo action. Only works if
	 * there is/are prior undo(s) before the redo(s).
	 */
	public void redoTask() {
		try {
			OldCommand toRedo = historyObject.getFromRedoList();
			OldCommand.COMMAND_TYPE cmdType = toRedo.getCommandType();

			switch (cmdType) {
			case ADD_TASK:
				addTaskList(toRedo.getTaskList());
				break;
			case DELETE_TASK:
				deleteTask(toRedo.getIndexList(), true);
				break;
			case COMPLETE_TASK:
				markAsCompleteListUndoOp(toRedo.getTaskList(), toRedo.getIndexList());
				break;
			case INCOMPLETE_TASK:
				markAsIncompleteListUndoOp(toRedo.getTaskList(), toRedo.getIndexList());
				break;
			case MODIFY_TASK:
				/*
				 * For modify the Task list contains two tasks. The first one is
				 * the oldTask and the second one is the newTask. Delete old,
				 * add new.
				 */
				deleteSingleTask(toRedo.getIndexList().get(0));
				addTask(toRedo.getTaskList().get(1), true, 1);
				break;
			default:
				// go back to original home screen
				// incomplete
			}
			setFeedBack(FEEDBACK_REDO_VALID);
		} catch (Exception e) {
			setFeedBack(FEEDBACK_REDO_INVALID);
		}
	}

	// add task when undo/redo is called
	public void addTaskList(ArrayList<Task> taskList) {
		for (Task newTask : taskList) {
			addTask(newTask, true, 0);
		}
	}

	// complete task when undo/redo is called
	public void markAsCompleteListUndoOp(ArrayList<Task> taskList, ArrayList<Integer> indexList) {
		for (Task task : taskList) {
			markTaskComplete(task);
		}
	}

	// mark task as incomplete when undo/redo is called
	public void markAsIncompleteListUndoOp(ArrayList<Task> taskList, ArrayList<Integer> indexList) {
		for (Task task : taskList) {
			markTaskIncomplete(task);
		}
	}

	// delete single task when undo/redo is called
	public void deleteSingleTask(int index) {
		if (index > 0) {
			if (index <= scheduledTasksOverDue.size()) {
				scheduledTasksOverDue.remove(index - 1);
			} else if (index <= scheduledTasksOverDue.size() + scheduledTasksToDo.size()) {
				scheduledTasksToDo.remove(index - 1 - scheduledTasksOverDue.size());
			} else if (index <= scheduledTasksToDo.size() + floatingTasksToDo.size() + scheduledTasksOverDue.size()) {
				floatingTasksToDo.remove(index - 1 - scheduledTasksToDo.size() - scheduledTasksOverDue.size());
			} else {
				setFeedBack(FEEDBACK_NON_EXISTENT_TASK_NUM);
			}
		}
		setFeedBack(FEEDBACK_TASK_DELETED);
	}

	/*
	 * search tasks based on parameters indicated by user. Parameters can
	 * include dates or task descriptions or letters with which task names start
	 */
	private void searchTask(Task taskToFind) {
		if ((taskToFind.getDescription() != null) && !(taskToFind.getDescription().isEmpty())) {
			if (taskToFind.getDescription().equalsIgnoreCase("all")) {
				execute(Command.COMMAND_TYPE.VIEW_ALL, null, null);
				return;
			}
		}

		isSearchCommand = true;
		ArrayList<Task> searchTaskList = new ArrayList<Task>();
		ArrayList<Integer> searchIndexList = new ArrayList<Integer>();

		if (taskToFind.getStartDate() != null && taskToFind.getStartDate() == LocalDate.MIN) {
			searchTaskList = new ArrayList<Task>(getScheduledTasksOverDue());
			for (int i = 0; i < scheduledTasksOverDue.size(); i++) {
				searchIndexList.add(i + 1);
			}
		} else {
			Search obj = new Search();
			obj.searchTask(taskToFind);
			searchTaskList = obj.getSearchList();
			searchIndexList = obj.getSearchIndexList();
		}

		if (searchTaskList.size() > 0) {
			setFeedBack(FEEDBACK_SEARCH_VALID);
			BottomBottom.setSearchResult(searchTaskList, searchIndexList);
			// (new TempCLI()).printSearchTaskLists(searchTaskList,
			// searchIndexList);
		} else {
			BottomBottom.failedSearch();
			setFeedBack(FEEDBACK_SEARCH_INVALID);
		}
	}

	public boolean hasSearchList() {
		return isSearchCommand;
	}

	/**
	 * Refreshing screen every minute. This method is invoked by the UI every
	 * minute.
	 */
	public void refresh() {
		if (!isSearchCommand) {
			if (isHomeScreen) {
				executeCommand("home");
			} else {
				executeCommand("view all");
			}
			historyObject.removeLastCommandFromHistory();
		}
	}

	/*
	 * exiting of program. exits once all data is saved into json files in
	 * storage
	 */
	private void exit() {
		System.exit(0);
	}
}
```
###### \Logic\Search.java
``` java
package Logic;

import java.util.ArrayList;

import ScheduleHacks.Task;

import java.time.LocalDate;

public class Search {

	private static final String STRING_WHITESPACE = " ";

	private static int count = 1;
	private ArrayList<Task> matchedTaskList = new ArrayList<Task>();
	private ArrayList<Integer> indexList = new ArrayList<Integer>();

	/****************** GETTER METHODS ***********************/

	/**
	 * The ArrayList<Task> returned by this method contains all the tasks that
	 * satisfy the search query input by the user.
	 * 
	 * @return matchedTaskList
	 */
	public ArrayList<Task> getSearchList() {
		return matchedTaskList;
	}

	/**
	 * The indexList contains the corresponding indexes of the tasks contained
	 * in the matchedTaskList.
	 * 
	 * @return indexList
	 */
	public ArrayList<Integer> getSearchIndexList() {
		return indexList;
	}

	/********************* OTHER METHODS ***********************/

	/**
	 * This method checks all 5 ArrayList<Task> to check for tasks that satisfy
	 * the conditions specified by taskToFind.
	 * 
	 * @param taskToFind
	 *            contains information regarding the search criteria.
	 */
	public void searchTask(Task taskToFind) {
		count = 0;
		Logic logicObj = Logic.getInstance();

		findMatches(logicObj.getScheduledTasksOverDue(), taskToFind);
		findMatches(logicObj.getScheduledTasksToDo(), taskToFind);
		findMatches(logicObj.getFloatingTasksToDo(), taskToFind);
		findMatches(logicObj.getScheduledTasksComplete(), taskToFind);
		findMatches(logicObj.getFloatingTasksComplete(), taskToFind);
	}

	/**
	 * This method checks the sourceList to see if it contains any task that
	 * satisfies criteria specified by taskToFind.
	 * 
	 * @param sourceList
	 *            contains a task list which is to be searched.
	 * @param taskToFind
	 *            contains information regarding search criteria.
	 */
	public void findMatches(ArrayList<Task> sourceList, Task taskToFind) {
		if (sourceList != null && !sourceList.isEmpty()) {
			for (Task task : sourceList) {
				count++; // count is used to maintain the index of the task

				// matching complete
				if (taskToFind.isComplete() && task.isComplete()) {
					indexList.add(count);
					matchedTaskList.add(task);
					continue;
				}
				// matching description
				if (taskToFind.getDescription() != null && !taskToFind.getDescription().isEmpty()) {
					if (hasMatchDescription(taskToFind, task)) {
						continue;
					}
				}
				// matching only end date
				if (taskToFind.getEndDate() != null && taskToFind.getStartDate() == null) {
					if (hasMatchSingleDate(taskToFind, task)) {
						continue;
					}
				}
				// matching date range
				if (taskToFind.getEndDate() != null && taskToFind.getStartDate() != null) {
					if (hasMatchDateRange(taskToFind, task)) {
						continue;
					}
				}
			}
		}
	}

	/**
	 * This method is invoked to check if taskToCheck has a startDate or endDate
	 * that matches with that specified in taskToFind.
	 * 
	 * @param taskToFind
	 *            contains information that needs to be matched.
	 * @param taskToCheck
	 *            is checked to see if it contains date specified
	 * @return true, if taskToCheck dates match with taskToFind, otherwise
	 *         false.
	 */
	public boolean hasMatchSingleDate(Task taskToFind, Task taskToCheck) {
		LocalDate dateToFind = taskToFind.getEndDate();
		if (taskToCheck.isScheduledTask()) {
			if (taskToCheck.getStartDate() != null && taskToCheck.getStartDate().isEqual(dateToFind)) {
				indexList.add(count);
				matchedTaskList.add(taskToCheck);
				return true;
			}
			if (taskToCheck.getEndDate().isEqual(dateToFind)) {
				indexList.add(count);
				matchedTaskList.add(taskToCheck);
				return true;
			}
		}
		return false;
	}

	/**
	 * This method is used to check if the startDate and endDate of taskToCheck
	 * lie within the range specified by taskToFind.
	 * 
	 * @param taskToFind
	 *            contains date range to be matched.
	 * @param taskToCheck
	 *            is checked to see if its dates lie within the range specified
	 *            by taskToFind.
	 * @return true, if taskToCheck dates lie within taskToFind date range,
	 *         otherwise false.
	 */
	public boolean hasMatchDateRange(Task taskToFind, Task taskToCheck) {
		LocalDate startDate = taskToFind.getStartDate();
		LocalDate endDate = taskToFind.getEndDate();

		if (taskToCheck.isScheduledTask()) {
			LocalDate taskEndDate = taskToCheck.getEndDate();
			if (taskToCheck.getStartDate() != null) {
				LocalDate taskStartDate = taskToCheck.getStartDate();
				if (dateLiesInRange(taskStartDate, startDate, endDate)) {
					indexList.add(count);
					matchedTaskList.add(taskToCheck);
					return true;
				} else if (taskStartDate.isBefore(startDate) && taskEndDate.isAfter(endDate)) {
					indexList.add(count);
					matchedTaskList.add(taskToCheck);
					return true;
				}
			}
			if (dateLiesInRange(taskEndDate, startDate, endDate)) {
				indexList.add(count);
				matchedTaskList.add(taskToCheck);
				return true;
			}
		}
		return false;
	}

	/**
	 * This method checks if the description contained in taskToFind is present
	 * in taskToCheck.
	 * 
	 * @param taskToFind
	 *            contains the description to match.
	 * @param taskToCheck
	 *            is check to see if contains parts of description specified in
	 *            taskToFind.
	 * @return true, if taskToCheck description contains words specified in
	 *         taskToFind description, false otherwise.
	 */
	public boolean hasMatchDescription(Task taskToFind, Task taskToCheck) {
		String descToFind = taskToFind.getDescription().toLowerCase();
		// if the description provided for searching is a single letter, all the
		// tasks starting with the particular letter are returned.
		if (descToFind.length() == 1) {
			if (taskToCheck.getDescription().toLowerCase().startsWith(descToFind)) {
				indexList.add(count);
				matchedTaskList.add(taskToCheck);
				return true;
			}
		} else {
			String[] wordList = descToFind.split(STRING_WHITESPACE);
			if (areWordsPresent(wordList, taskToCheck.getDescription().toLowerCase())
					|| descToFind.equalsIgnoreCase(taskToCheck.getDescription())) {
				indexList.add(count);
				matchedTaskList.add(taskToCheck);
				return true;
			}
		}
		return false;
	}

	/**
	 * This method checks if dateToCheck lies with startDate and endDate, both
	 * inclusive.
	 * 
	 * @param dateToCheck
	 * @param startDate
	 * @param endDate
	 * @return true, if dateToCheck lies within the range [startDate, endDate],
	 *         false otherwise.
	 */
	public boolean dateLiesInRange(LocalDate dateToCheck, LocalDate startDate, LocalDate endDate) {
		return dateToCheck.isEqual(startDate) || dateToCheck.isEqual(endDate)
				|| (dateToCheck.isAfter(startDate) && dateToCheck.isBefore(endDate));
	}

	/**
	 * This method checks if the all the words specified in wordList are
	 * included in text. It does not take order into consideration, also ignores
	 * single letters.
	 * 
	 * @param wordList
	 *            contains the list of words that should be present in text.
	 * @param text
	 * @return true if all the words in wordList are contained in text.
	 */
	public boolean areWordsPresent(String[] wordList, String text) {
		if (wordList.length == 0) {
			return false;
		}
		int countOneLetterWords = 0;
		for (String word : wordList) {
			if (word.length() > 1) {
				if (!text.contains(word)) {
					return false;
				}
			} else {
				countOneLetterWords++;
			}
		}
		if (countOneLetterWords == wordList.length) {
			return false;
		}
		return true;
	}
}
```
###### \Parser\Command.java
``` java

package Parser;

import java.util.ArrayList;

import ScheduleHacks.Task;

public class Command {

	public enum COMMAND_TYPE {
		ADD_TASK, DELETE_TASK, MODIFY_TASK, COMPLETE_TASK, INCOMPLETE_TASK, SEARCH_TASK, VIEW_LIST, VIEW_ALL, UNDO_TASK, REDO_TASK, SET_DIRECTORY, HOME, HELP, EXIT
	};

	public boolean isFirstWordCommand;

	/************** INSTANCE VARIABLES ********************/
	private Task taskDescription;
	private COMMAND_TYPE commandType;
	private ArrayList<Integer> indexList;

	/****************** CONSTRUCTORS **********************/

	public Command() {
		this.commandType = null;
		this.taskDescription = null;
		this.indexList = null;
	}

	// Parameterized Constructor that accepts a command word and task details
	public Command(String commandFirstWord, Task newTaskDetails) throws Exception {
		setCommandType(commandFirstWord);
		setTaskDetails(newTaskDetails);
		setIndexList(new ArrayList<Integer>());
	}

	public Command(String commandFirstWord, Task newTaskDetails, ArrayList<Integer> newIndexList) throws Exception {
		setCommandType(commandFirstWord);
		setTaskDetails(newTaskDetails);
		setIndexList(newIndexList);
	}

	// Parameterized Constructor that accepts another Command
	public Command(Command newCommand) {
		this.commandType = newCommand.commandType;
		this.taskDescription = newCommand.taskDescription;
		this.indexList = newCommand.indexList;
	}

	/****************** SETTER METHODS ***********************/
	public void setCommandType(String commandFirstWord) throws Exception {
		this.commandType = determineCommandType(commandFirstWord);
	}

	public void setCommandType(COMMAND_TYPE commandFirstWord) throws Exception {
		this.commandType = commandFirstWord;
	}

	public void setTaskDetails(Task newTaskDetails) {
		this.taskDescription = newTaskDetails;
	}

	public void setIndexList(ArrayList<Integer> newIndexList) {
		this.indexList = newIndexList;
	}

	/****************** GETTER METHODS ***********************/

	// It throws an error when the command type is Invalid.
	// Need to change it later on.
	public COMMAND_TYPE getCommandType() throws Exception {
		if (commandType == null) {
			throw new Exception("Invalid Command Type");
		}
		return this.commandType;
	}

	public Task getTaskDetails() {
		return this.taskDescription;
	}

	public ArrayList<Integer> getIndexList() {
		return this.indexList;
	}

	/****************** OTHER METHODS ***********************/

	/**
	 * This operation is used to find what does the user want to do to the Task.
	 * 
	 * @param commandFirstWord
	 *            is the first word of the UserCommand. It has been reassigned
	 *            by the Parser to account for variations. Eg.; both "add" and
	 *            "create" are reassigned as "add"
	 * @return the commandType, so that necessary actions can be performed.
	 */
	private COMMAND_TYPE determineCommandType(String commandFirstWord) throws Exception {
		if (commandFirstWord.equals(ParserConstants.COMMAND_INVALID)) {
			throw new Exception("command type string cannot be null!");
		}
		if (commandFirstWord.equals(ParserConstants.COMMAND_EMPTY)) {
			throw new Exception("command type string cannot be empty!");
		}

		isFirstWordCommand = true;
		if (hasInDictionary(ParserConstants.COMMAND_ADD, commandFirstWord)) {
			return COMMAND_TYPE.ADD_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_DELETE, commandFirstWord)) {
			return COMMAND_TYPE.DELETE_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_MODIFY, commandFirstWord)) {
			return COMMAND_TYPE.MODIFY_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_COMPLETE, commandFirstWord)) {
			return COMMAND_TYPE.COMPLETE_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_INCOMPLETE, commandFirstWord)) {
			return COMMAND_TYPE.INCOMPLETE_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_SEARCH, commandFirstWord)) {
			return COMMAND_TYPE.SEARCH_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_VIEW, commandFirstWord)) {
			return COMMAND_TYPE.VIEW_LIST;
		} else if (hasInDictionary(ParserConstants.COMMAND_UNDO, commandFirstWord)) {
			return COMMAND_TYPE.UNDO_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_REDO, commandFirstWord)) {
			return COMMAND_TYPE.REDO_TASK;
		} else if (hasInDictionary(ParserConstants.COMMAND_SET_DIRECTORY, commandFirstWord)) {
			return COMMAND_TYPE.SET_DIRECTORY;
		} else if (hasInDictionary(ParserConstants.COMMAND_HOME, commandFirstWord)) {
			return COMMAND_TYPE.HOME;
		} else if (hasInDictionary(ParserConstants.COMMAND_HELP, commandFirstWord)) {
			return COMMAND_TYPE.HELP;
		} else if (hasInDictionary(ParserConstants.COMMAND_EXIT, commandFirstWord)) {
			return COMMAND_TYPE.EXIT;
		} else {
			isFirstWordCommand = false;
			return COMMAND_TYPE.ADD_TASK;
		}
	}

	/**
	 * This operation helps us to overcome the variations in command type input
	 * by the user.
	 * 
	 * @param commandFirstWord
	 *            is the first word of the user's command.
	 * @param commandDictionary
	 *            is the String dictionary passed for determineCommandType()
	 * 
	 * @return true if the first word from the user's command is contained in
	 *         the respective dictionary, otherwise false
	 */
	private boolean hasInDictionary(String[] commandDictionary, String commandFirstWord) {
		for (String command : commandDictionary) {
			if (command.equalsIgnoreCase(commandFirstWord))
				return true;
		}
		return false;
	}
}
```
###### \Parser\CommandParser.java
``` java

package Parser;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import Parser.Command.COMMAND_TYPE;
import ScheduleHacks.Task;

/**
 * This class is invoked whenever a String input by the user needs to be parsed
 * to retrieve the required details.
 * 
 * This is mostly a facade class which in highly dependant on the DateParser,
 * TimeParser and IndexParser.
 */

public class CommandParser {

	/**
	 * This method is used by the Logic to get the parsed components from the
	 * input user command.
	 * 
	 * @param newUserCommand
	 *            command input by the user
	 * @return parsedCommand Command type object which contains the commandType,
	 *         newTaskDetails, and an index number
	 * @throws Exception
	 */
	public static Command getParsedCommand(String newUserCommand) throws Exception {
		return parseCommand(cleanupExtraWhitespace(newUserCommand));
	}

	private static Command parseCommand(String userCommand) throws Exception {
		Command parsedCommand = new Command();

		String commandType = getFirstWord(userCommand);
		parsedCommand.setCommandType(commandType);

		if (parsedCommand.isFirstWordCommand) {
			userCommand = removeFirstWord(userCommand);
		}
		Task taskDetails = findTaskDetails(parsedCommand, userCommand);
		parsedCommand.setTaskDetails(taskDetails);

		return parsedCommand;
	}

	public static Task findTaskDetails(Command command, String taskStatement) throws Exception {
		COMMAND_TYPE commandType = command.getCommandType();

		if (hasIndexNumber(commandType)) {
			IndexParser indexParser = new IndexParser(command, taskStatement);
			indexParser.findIndexList();
			command.setIndexList(indexParser.getIndexList());
			taskStatement = indexParser.getTaskDetails();
		}
		if (!hasTaskDetails(commandType)) {
			if (hasIndexNumber(commandType)) {
				if (taskStatement != null && !taskStatement.isEmpty() && command.getIndexList() == null) {
					command.setIndexList(generateDefaultIntList());
				}
			}
			return null;
		} else {
			// if (taskStatement != null && !taskStatement.isEmpty()) {
			Task newTask = new Task();
			switch (commandType) {
			case ADD_TASK:
				newTask = addNewTask(taskStatement);
				break;
			case MODIFY_TASK:
				newTask = sendEditTaskInfoToLogic(taskStatement);
				break;
			case SEARCH_TASK:
				newTask = getCriteria(taskStatement);
				break;
			case VIEW_LIST:
				newTask = getCriteria(taskStatement);
				break;
			case SET_DIRECTORY:
				newTask = setDirectory(command, taskStatement);
				break;
			case HELP:
				newTask = setHelpParameters(command, taskStatement);
				break;
			default:
				// do nothing
				break;
			}
			if (newTask != null) {
				newTask.setDescription(parseDescription(newTask.getDescription()));
			}
			if (command.getCommandType().equals(COMMAND_TYPE.HELP)
					|| (taskStatement != null && !taskStatement.isEmpty())) {
				return newTask;
			} else {
				throw new Exception("Empty Task Description");
			}
			// }
		}
		// throw new Exception("Empty Task Description");
	}

	/**
	 * This method is invoked when the user wants to change directory of his
	 * task list. It parses taskStatement to obtain directory details.
	 * 
	 * @param taskStatement
	 * @return newTask, set with all parameters to specify new directory route.
	 */
	public static Task setDirectory(Command cmd, String taskStatement) {
		Task newTask = new Task();
		taskStatement = cleanupExtraWhitespace(taskStatement);

		if (taskStatement.matches(ParserConstants.REGEX_POSSIBLE_DIRECTORY)
				|| taskStatement.equalsIgnoreCase("default")) {
			newTask.setDescription(taskStatement);
		} else {
			// if parameter provided is not of a directory, it is considered to
			// be an add command.
			try {
				cmd.setCommandType(COMMAND_TYPE.ADD_TASK);
			} catch (Exception e) {
				// do nothing
			}
			newTask = addNewTask("set " + taskStatement);
		}

		return newTask;
	}

	public static Task setHelpParameters(Command cmd, String taskStatement) {
		if (taskStatement == null || taskStatement.isEmpty()) {
			return null;
		}
		Task newTask = new Task();
		try {
			cmd.setCommandType(COMMAND_TYPE.ADD_TASK);
		} catch (Exception e) {
			// do nothing
		}
		newTask = addNewTask("Help " + taskStatement);
		return newTask;
	}

	public static Task addNewTask(String taskStatement) {
		Task newTask = new Task();
		// Getting date and time lists from task statement
		DateParser dateParser = new DateParser(taskStatement);
		dateParser.findDates();
		ArrayList<LocalDate> dateList = dateParser.getDateList();

		TimeParser timeParser = new TimeParser(dateParser.getTaskDetails(), dateList);
		timeParser.findTimes();
		ArrayList<LocalTime> timeList = timeParser.getTimeList();

		if (dateList == null && timeList == null) {
			newTask = addFloatingTaskDetails(taskStatement);
		} else {
			newTask = addScheduledTaskDetails(timeParser.getTaskDetails(), dateList, timeList);
		}
		return newTask;
	}

	/**
	 * This method is used to prepare an edit task to send to Logic
	 * 
	 * @param taskStatement
	 * @return Task, with taskStatement as Description
	 */
	public static Task sendEditTaskInfoToLogic(String taskStatement) {
		Task newTask = new Task();
		newTask.setDescription(taskStatement);
		return newTask;
	}

	/**
	 * This method is invoked by Logic, containing the old Task object that
	 * needs to be edited and the edit details
	 * 
	 * @param oldTask
	 * @param editStatement,
	 *            contains edit parameters
	 * @return
	 */
	public static Task editExistingTask(Task oldTask, String editStatement) {
		Task newTask = new Task(oldTask);
		if (requiresDeletingParameters(editStatement)) {
			editStatement = removeFirstWord(editStatement);
			deleteParameters(newTask, getParameterList(editStatement));
		} else {
			newTask = setEditParameters(editStatement, newTask);
		}
		return newTask;
	}

	public static Task getCriteria(String taskStatement) throws Exception {
		Task newTask = new Task();
		taskStatement = cleanupExtraWhitespace(taskStatement);
		String storeTaskStatement = taskStatement;
		String firstWord = getFirstWord(taskStatement);

		if (hasInDictionary(ParserConstants.UPCOMING_PERIOD_KEYWORD, firstWord)) {
			taskStatement = setUpcomingDateRange(taskStatement, newTask, firstWord);
		} else if (firstWord.equalsIgnoreCase(ParserConstants.STRING_OVERDUE)) {
			taskStatement = removeFirstWord(taskStatement);
			setOverdueCriteria(newTask);
		} else {
			taskStatement = getSearchCriteria(taskStatement, newTask);
		}

		try {
			if (taskStatement != null) {
				taskStatement = cleanupExtraWhitespace(taskStatement);
			}
			if (taskStatement == null || taskStatement.isEmpty()) {
				taskStatement = storeTaskStatement;
			}
			newTask.setDescription(taskStatement);
		} catch (Exception e) {
			// do nothing
		}
		return newTask;
	}

	/**
	 * This method is invoked when the user wants to search for overdue tasks.
	 * It sets parameters so as to include every task before the present instant
	 * of time.
	 * 
	 * @param newTask
	 */
	public static void setOverdueCriteria(Task newTask) {
		newTask.setStartDate(LocalDate.MIN);
		newTask.setEndDate(getCurrentDate());
		newTask.setEndTime(LocalTime.now().plusSeconds(5));
		newTask.setAsIncomplete();
	}

	public static String getSearchCriteria(String taskStatement, Task newTask) throws Exception {
		String firstWord = getFirstWord(taskStatement);

		if (hasInDictionary(ParserConstants.COMMAND_COMPLETE, firstWord)) {
			newTask.setAsComplete();
			taskStatement = taskStatement.replace(firstWord, ParserConstants.STRING_WHITESPACE);
		} else {
			DateParser dateObj = new DateParser(taskStatement);
			LocalDate currentDate = getCurrentDate();
			dateObj.findDates();
			if ((new DateParser()).hasDayDuration(taskStatement)) {
				taskStatement = addCriteriaDateDuration(newTask, taskStatement);
			} else if (dateObj.getDateList() != null) {
				int dateListSize = dateObj.getDateList().size();
				newTask.setEndDate(dateObj.getDateList().get(dateListSize - 1));
				if (dateListSize > 1) {
					newTask.setStartDate(dateObj.getDateList().get(ParserConstants.FIRST_INDEX));
				}
				taskStatement = dateObj.getTaskDetails();
			} else if (dateObj.isMonth(firstWord)) {
				// if month
				int monthNum = dateObj.getMonthNum(firstWord);
				int currentMonthNum = currentDate.getMonthValue();
				if (monthNum < currentMonthNum) {
					newTask.setStartDate(
							LocalDate.of(currentDate.getYear() + 1, monthNum, ParserConstants.FIRST_DAY_OF_MONTH));
				} else {
					newTask.setStartDate(
							LocalDate.of(currentDate.getYear(), monthNum, ParserConstants.FIRST_DAY_OF_MONTH));
				}
				newTask.setEndDate(newTask.getStartDate().plusMonths(1).minusDays(1));
				taskStatement = taskStatement.replace(firstWord, ParserConstants.STRING_WHITESPACE);

			}
		}
		return taskStatement;
	}

	public static String setUpcomingDateRange(String taskStatement, Task newTask, String firstWord) {
		try {
			DateParser dateObj = new DateParser(taskStatement);
			LocalDate currentDate = getCurrentDate();
			String secondWord = getFirstWord(removeFirstWord(taskStatement));

			if (secondWord.equalsIgnoreCase("month")) {
				LocalDate newDate = currentDate.plusMonths(indexOf(firstWord, ParserConstants.UPCOMING_PERIOD_KEYWORD));

				newTask.setStartDate(
						LocalDate.of(newDate.getYear(), newDate.getMonth(), ParserConstants.FIRST_DAY_OF_MONTH));

				newTask.setEndDate(newTask.getStartDate().plusMonths(1).minusDays(1));

				taskStatement = taskStatement.replaceFirst(firstWord + " " + secondWord,
						ParserConstants.STRING_WHITESPACE);
			} else if (secondWord.equalsIgnoreCase("week")) {
				newTask.setStartDate(dateObj.getDayOfWeekDate("Sunday").minusDays(ParserConstants.DAYS_IN_WEEK
						- indexOf(firstWord, ParserConstants.UPCOMING_PERIOD_KEYWORD) * ParserConstants.DAYS_IN_WEEK));

				newTask.setEndDate(newTask.getStartDate().plusDays(ParserConstants.DAYS_IN_WEEK));

				taskStatement = taskStatement.replaceFirst(firstWord + " " + secondWord,
						ParserConstants.STRING_WHITESPACE);
			} else if (secondWord.equalsIgnoreCase("year")) {

				newTask.setStartDate(LocalDate
						.of(currentDate.getYear() + indexOf(firstWord, ParserConstants.UPCOMING_PERIOD_KEYWORD), 1, 1));

				newTask.setEndDate(LocalDate.of(
						currentDate.getYear() + indexOf(firstWord, ParserConstants.UPCOMING_PERIOD_KEYWORD), 12, 31));

				taskStatement = taskStatement.replaceFirst(firstWord + " " + secondWord,
						ParserConstants.STRING_WHITESPACE);
			} else if ((new DateParser()).hasDayDuration(removeFirstWord(taskStatement))) {
				taskStatement = removeFirstWord(taskStatement);
				taskStatement = addCriteriaDateDuration(newTask, taskStatement);
			}
		} catch (Exception e) {
			// do nothing
		}
		return taskStatement;
	}

	public static String addCriteriaDateDuration(Task newTask, String taskStatement) {
		DateParser dateObj = new DateParser(taskStatement);
		String dayDuration = dateObj.getDayDurationWord(taskStatement);
		newTask.setStartDate(getCurrentDate());
		newTask.setEndDate(dateObj.getParsedDayDurationDate(dayDuration));
		return taskStatement.replace(dayDuration, ParserConstants.STRING_EMPTY);
	}

	/**
	 * This method sets all the elements of the task object matching the
	 * parametersToDelete list as Empty.
	 * 
	 * @param taskStatement
	 * @param newTask
	 */
	public static Task setEditParameters(String taskStatement, Task oldTask) {
		DateParser dateParser = new DateParser(taskStatement);
		dateParser.findDates();
		ArrayList<LocalDate> dateList = dateParser.getDateList();

		TimeParser timeParser = new TimeParser(dateParser.getTaskDetails(), dateList);
		timeParser.findTimes();
		ArrayList<LocalTime> timeList = timeParser.getTimeList();
		taskStatement = timeParser.getTaskDetails();

		if (oldTask.isFloatingTask()) {
			oldTask = editFloatingTask(taskStatement, oldTask, dateList, timeList);
		} else if (oldTask.isScheduledTask()) {
			oldTask = editScheduledTask(taskStatement, oldTask, dateList, timeList);
		}

		return oldTask;
	}

	/**
	 * This method is used to edit parameters of initial Scheduled tasks
	 * oldTask.
	 * 
	 * @param taskStatement
	 * @param oldTask
	 * @param dateList
	 * @param timeList
	 * @return the edited scheduled Task
	 */
	public static Task editScheduledTask(String taskStatement, Task oldTask, ArrayList<LocalDate> dateList,
			ArrayList<LocalTime> timeList) {

		ArrayList<LocalDate> oldDateList = getTaskDateAsList(oldTask);
		ArrayList<LocalTime> oldTimeList = getTaskTimeAsList(oldTask);

		if (dateList != null && timeList != null) {
			DateTimeParser objDateTime = new DateTimeParser(dateList, timeList);
			objDateTime.arrangeDateTimeList();
			dateList = objDateTime.getDateList();
			timeList = objDateTime.getTimeList();
		} else if (timeList != null || dateList != null) {
			if (timeList != null) {
				if (timeList.size() > oldTimeList.size()) {
					dateList = new ArrayList<LocalDate>();
					dateList.add(oldTask.getEndDate());
					if (LocalDateTime.of(oldTask.getEndDate(), timeList.get(ParserConstants.FIRST_INDEX))
							.isAfter(LocalDateTime.of(oldTask.getEndDate(), timeList.get(1)))) {
						dateList.add(oldTask.getEndDate().plusDays(1));
					} else {
						dateList.add(oldTask.getEndDate());
					}
				} else if (timeList.size() == oldTimeList.size()) {
					dateList = new ArrayList<LocalDate>(oldDateList);
				} /*
					 * else { oldTask.setStartDate(null); }
					 */
			} else {
				if (dateList.size() > oldDateList.size()) {
					timeList = new ArrayList<LocalTime>();
					timeList.add(LocalTime.MAX);
					timeList.add(oldTask.getEndTime());
				} else if (dateList.size() < oldDateList.size()) {
					/*
					 * oldTask.setStartDate(null); oldTask.setStartTime(null);
					 */
					oldTask.setEndTime(LocalTime.MAX);
				} else {
					timeList = new ArrayList<LocalTime>(oldTimeList);
				}
			}
			DateTimeParser objDateTime = new DateTimeParser(dateList, timeList);
			objDateTime.arrangeDateTimeList();
			dateList = objDateTime.getDateList();
			timeList = objDateTime.getTimeList();
		}

		setDateTimeNull(oldTask);
		setDates(dateList, oldTask);
		setTimes(timeList, oldTask);

		if (taskStatement != null && !taskStatement.isEmpty()) {
			oldTask.setDescription(taskStatement);
		}

		return oldTask;
	}

	/**
	 * This method sets the date and time of the given task to null
	 * 
	 * @param task
	 */
	public static void setDateTimeNull(Task task) {
		task.setEndDate(null);
		task.setStartDate(null);
		task.setEndTime(null);
		task.setStartTime(null);
	}

	/**
	 * This method returns the dates of the given oldTask in an ArrayList
	 * format.
	 * 
	 * @param oldTask
	 * @return ArrayList<LocalDate>; dates in list format
	 */
	public static ArrayList<LocalDate> getTaskDateAsList(Task oldTask) {
		ArrayList<LocalDate> oldDateList = new ArrayList<LocalDate>();
		if (oldTask.getStartDate() != null) {
			oldDateList.add(oldTask.getStartDate());
		}
		oldDateList.add(oldTask.getEndDate());
		return oldDateList;
	}

	/**
	 * This method returns the times of the given oldTask in an ArrayList
	 * format.
	 * 
	 * @param oldTask
	 * @return ArrayList<LocalTime>; times in list format
	 */
	public static ArrayList<LocalTime> getTaskTimeAsList(Task oldTask) {
		ArrayList<LocalTime> oldTimeList = new ArrayList<LocalTime>();
		if (oldTask.getStartTime() != null) {
			oldTimeList.add(oldTask.getStartTime());
		}
		oldTimeList.add(oldTask.getEndTime());
		return oldTimeList;
	}

	public static Task editFloatingTask(String taskStatement, Task oldTask, ArrayList<LocalDate> dateList,
			ArrayList<LocalTime> timeList) {
		if (dateList != null || timeList != null) {
			if (taskStatement != null && !taskStatement.isEmpty()) {
				oldTask = addScheduledTaskDetails(taskStatement, dateList, timeList);
			} else {
				oldTask = addScheduledTaskDetails(oldTask.getDescription(), dateList, timeList);
			}
		} else {
			if (taskStatement != null && !taskStatement.isEmpty()) {
				oldTask.setDescription(taskStatement);
			}
		}

		return oldTask;
	}

	/**
	 * This method sets all the elements of the task object matching the
	 * parametersToDelete list as Empty.
	 * 
	 * @param oldTask
	 * @param parametersToDelete
	 */
	public static void deleteParameters(Task oldTask, ArrayList<String> parametersToDelete) {
		for (String parameter : parametersToDelete) {
			if (hasInDictionary(ParserConstants.PARAMETER_DATE, parameter)) {
				oldTask.setEndDate(null);
				oldTask.setStartDate(null);
				oldTask.setStartTime(null);
				oldTask.setEndTime(null);
				oldTask.setFloatingTask();
			} else if (hasInDictionary(ParserConstants.PARAMETER_TIME, parameter)) {
				if (oldTask.getStartTime() != null) {
					oldTask.setStartTime(LocalTime.MAX);
				}
				oldTask.setEndTime(LocalTime.MAX);
			} else if (hasInDictionary(ParserConstants.PARAMETER_DESCRIPTION, parameter)) {
				oldTask.setDescription(ParserConstants.STRING_EMPTY);
			}
		}
	}

	/**
	 * This method is used to check if the corresponding command types require
	 * an attached task information.
	 * 
	 * @param commandType
	 * @return true, if the command type requires task information false,
	 *         otherwise Only add and modify functionalities require task
	 *         details.
	 */
	public static boolean hasTaskDetails(COMMAND_TYPE commandType) {
		switch (commandType) {
		case COMPLETE_TASK:
			return false;
		case INCOMPLETE_TASK:
			return false;
		case DELETE_TASK:
			return false;
		case UNDO_TASK:
			return false;
		case REDO_TASK:
			return false;
		case HOME:
			return false;
		/*
		 * case HELP: return false;
		 */
		case EXIT:
			return false;
		default:
			return true;
		}
	}

	/**
	 * This method is used to check if the corresponding command types require
	 * an attached task index number.
	 * 
	 * @param commandType
	 * @return true, if the command type requires index number false, otherwise
	 *         Complete, delete and modify functionalities require index
	 *         numbers.
	 */
	public static boolean hasIndexNumber(COMMAND_TYPE commandType) {
		switch (commandType) {
		case COMPLETE_TASK:
			return true;
		case INCOMPLETE_TASK:
			return true;
		case DELETE_TASK:
			return true;
		case MODIFY_TASK:
			return true;
		default:
			return false;
		}
	}

	protected static Task addFloatingTaskDetails(String taskStatement) {
		Task newTask = new Task();
		newTask.setDescription(taskStatement);
		newTask.setFloatingTask();
		return newTask;
	}

	protected static Task addScheduledTaskDetails(String taskStatement, ArrayList<LocalDate> dateList,
			ArrayList<LocalTime> timeList) {
		DateTimeParser objDateTime = new DateTimeParser(dateList, timeList);
		objDateTime.arrangeDateTimeList();

		Task newTask = new Task();
		newTask.setDescription(taskStatement);
		newTask.setScheduledTask();
		setDates(objDateTime.getDateList(), newTask);
		setTimes(objDateTime.getTimeList(), newTask);

		return newTask;
	}

	/**
	 * This method is used to get rid of unnecessary special characters in the
	 * task description. Only currency symbols before dates and times are
	 * allowed.
	 * 
	 * @param description
	 * @return task description after removing all special characters.
	 */
	public static String parseDescription(String description) {
		if (description != null && !description.isEmpty()) {
			String parsedDescription = ParserConstants.STRING_EMPTY;
			String[] words = description.split(ParserConstants.STRING_WHITESPACE);
			for (String word : words) {
				char firstChar = word.charAt(ParserConstants.FIRST_INDEX);
				if (Character.isLetterOrDigit(firstChar)
						|| (Character.getType(firstChar) == Character.CURRENCY_SYMBOL)) {
					parsedDescription += ParserConstants.STRING_WHITESPACE + word;
					continue;
				}
				parsedDescription += ParserConstants.STRING_WHITESPACE + getDescriptionSansSpecialChars(word);
			}
			return cleanupExtraWhitespace(parsedDescription);
		}
		return ParserConstants.STRING_EMPTY;
	}

	public static String getDescriptionSansSpecialChars(String description) {
		String tempWordStore = description.substring(ParserConstants.FIRST_INDEX + 1);
		DateParser dateObj = new DateParser(tempWordStore);
		dateObj.findDates();
		TimeParser timeObj = new TimeParser(tempWordStore);
		timeObj.findTimes();
		if (dateObj.getDateList() != null || timeObj.getTimeList() != null) {
			return tempWordStore;
		} else {
			return description;
		}
	}

	/**
	 * This method is used to check if any delete keywords are present in an
	 * edit statement.
	 * 
	 * @param taskStatement
	 * @return returns true if delete keywords are present in taskStatement;
	 *         false otherwise.
	 */
	public static boolean requiresDeletingParameters(String taskStatement) {
		taskStatement = cleanupExtraWhitespace(taskStatement);
		try {
			String firstWord = getFirstWord(taskStatement);
			if (hasInDictionary(ParserConstants.COMMAND_DELETE, firstWord)) {
				getSecondWord(taskStatement); /* Just to check if not null */
				return true;
			}
		} catch (Exception e) {
			// do nothing
			// if exception, means no conversion
			// thus return false
		}
		return false;
	}

	/**
	 * This method splits up the words in taskStatement at the whitespace.
	 * 
	 * @param taskStatement
	 * @return an arrayList of words contained in taskStatement
	 */
	public static ArrayList<String> getParameterList(String taskStatement) {
		taskStatement = cleanupExtraWhitespace(taskStatement);
		String[] parameters = taskStatement.split(ParserConstants.STRING_WHITESPACE);
		return new ArrayList<String>(Arrays.asList(parameters));
	}

	/**
	 * This method sets the first date of dateList as StartDate and last date of
	 * the list as endDate of the given newTask object. If only one date is
	 * present in the dateList, it is assigned as the endDate.
	 * 
	 * @param dateList
	 * @param newTask
	 */
	public static void setDates(ArrayList<LocalDate> dateList, Task newTask) {
		if (dateList != null) {
			newTask.setEndDate(dateList.get(dateList.size() - 1));
			if (dateList.size() > 1) {
				newTask.setStartDate(dateList.get(ParserConstants.FIRST_INDEX));
			}
		}
	}

	/**
	 * This method sets the first time of timeList as StartTime and last time of
	 * the list as endTime of the given newTask object. If only one time is
	 * present in the timeList, it is assigned as the endTime.
	 * 
	 * @param timeList
	 * @param newTask
	 */
	public static void setTimes(ArrayList<LocalTime> timeList, Task newTask) {
		if (timeList != null) {
			newTask.setEndTime(timeList.get(timeList.size() - 1));
			if (timeList.size() > 1) {
				newTask.setStartTime(timeList.get(ParserConstants.FIRST_INDEX));
			}
		}
	}

	/**
	 * This method gets today's date.
	 * 
	 * @return today's date as LocalDate object.
	 */
	public static LocalDate getCurrentDate() {
		return LocalDate.now();
	}

	/**
	 * This method returns an Integer ArrayList consisting of only -1.
	 * 
	 * @return Integer ArrayList consisting of only -1
	 */
	public static ArrayList<Integer> generateDefaultIntList() {
		ArrayList<Integer> defaultList = new ArrayList<Integer>();
		defaultList.add(ParserConstants.DEFAULT_INDEX_NUMBER);
		return defaultList;
	}

	/**
	 * This method is used to retrieve the first word from the user's command,
	 * which is the command action(Eg., add, delete).
	 * 
	 * @param userCommand
	 *            which is to be executed.
	 * 
	 * @return the first word of the user command, which is the command type.
	 */
	static String getFirstWord(String userCommand) throws Exception {
		userCommand = userCommand.trim();

		int splitPosition = userCommand.indexOf(ParserConstants.WHITE_SPACE);
		if (splitPosition == ParserConstants.NO_WHITE_SPACE) {
			if (userCommand.length() > 0) {
				splitPosition = userCommand.length();
			} else {
				throw new Exception("Empty User Command");
			}
		}
		return userCommand.substring(ParserConstants.FIRST_INDEX, splitPosition);
	}

	/**
	 * This operation removes the first word from the user's command, which is
	 * the command type.
	 * 
	 * @return taskStatement which is exclusive of the command type.
	 */
	static String removeFirstWord(String userCommand) {
		userCommand = cleanupExtraWhitespace(userCommand);
		int whiteSpacePosition = userCommand.indexOf(ParserConstants.WHITE_SPACE);

		if (whiteSpacePosition != ParserConstants.NO_WHITE_SPACE) {
			return userCommand.substring(whiteSpacePosition).trim();
		}

		return null;
	}

	public static String getSecondWord(String statement) throws Exception {
		return getFirstWord(removeFirstWord(statement));
	}

	/**
	 * This method returns the index of word in array[].
	 * 
	 * @param word
	 * @param array
	 * @return index if word is present in array[], otherwise -1.
	 */
	public static int indexOf(String word, String[] array) {
		if (hasInDictionary(array, word)) {
			for (int index = ParserConstants.FIRST_INDEX; index < array.length; index++) {
				if (word.equalsIgnoreCase(array[index])) {
					return index;
				}
			}
		}
		return -1; // if absent
	}

	/**
	 * This method checks if wordToFind is present in dictionary[].
	 * 
	 * @param dictionary
	 * @param wordToFind
	 * @return true if present, else false.
	 */
	private static boolean hasInDictionary(String[] dictionary, String wordToFind) {
		if (wordToFind != null && !wordToFind.isEmpty()) {
			for (String dictionaryWords : dictionary) {
				if (dictionaryWords.equalsIgnoreCase(wordToFind))
					return true;
			}
		}
		return false;
	}

	/**
	 * This method removes the unnecessary white spaces present in the string.
	 * 
	 * @param someText
	 *            is any string with several white spaces.
	 * @return someText excluding the extra unnecessary white spaces.
	 */
	public static String cleanupExtraWhitespace(String someText) {
		Pattern extraSpace = Pattern.compile(ParserConstants.REGEX_EXTRA_WHITESPACE);
		Matcher regexMatcher = extraSpace.matcher(someText.trim());
		String cleanText = regexMatcher.replaceAll(ParserConstants.STRING_WHITESPACE);
		return cleanText;
	}

}
```
###### \Parser\CommandParserTest.java
``` java

package Parser;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

import java.time.LocalDate;
import java.time.LocalTime;

import Parser.Command.COMMAND_TYPE;

import ScheduleHacks.Task;

public class CommandParserTest {

	@Test
	public void testGetFirstWord1() throws Exception {
		String testString = "add life is great";
		String output = CommandParser.getFirstWord(testString);
		assertEquals(output, "add");
	}

	@Test
	public void testGetFirstWord2() throws Exception {
		String testString = "Schedule";
		String output = CommandParser.getFirstWord(testString);
		assertEquals(output, "Schedule");
	}

	@Test
	public void testRemoveFirstWord() {
		String testString = "add life is great";
		String output = CommandParser.removeFirstWord(testString);
		assertEquals(output, "life is great");
	}

	@Test
	public void testCleanupExtraWhitespace1() {
		String testString = "  checking   random text  123   321       ";
		String output = CommandParser.cleanupExtraWhitespace(testString);
		String expected = "checking random text 123 321";
		assertEquals(expected, output);
	}

	@Test
	public void testCleanupExtraWhitespace2() {
		String testString = "textwithoutspace           ";
		String output = CommandParser.cleanupExtraWhitespace(testString);
		String expected = "textwithoutspace";
		assertEquals(expected, output);
	}

	/*
	 * Boundary case. Empty String.
	 */
	@Test
	public void testCleanupExtraWhitespace3() {
		String testString = "           ";
		String output = CommandParser.cleanupExtraWhitespace(testString);
		String expected = "";
		assertEquals(expected, output);
	}

	@Test
	public void checkGetParsedCommand1() throws Exception {
		String testString = "+ Meet ABCD   16.00 14/05/16 14/08/16 ";
		Command cmd = CommandParser.getParsedCommand(testString);
		Task newTask = cmd.getTaskDetails();
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
		assertEquals(COMMAND_TYPE.ADD_TASK, cmd.getCommandType());
		assertEquals("Meet ABCD", newTask.getDescription());
		assertEquals("16:00", newTask.getStartTime().toString());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals("2016-05-14", newTask.getStartDate().toString());
		assertEquals("2016-08-14", newTask.getEndDate().toString());
	}

	@Test
	public void checkGetParsedCommand2() throws Exception {
		String testString = "+ Meet ABCD   16";
		Command cmd = CommandParser.getParsedCommand(testString);
		Task newTask = cmd.getTaskDetails();
		assertEquals(true, newTask.isFloatingTask());
		assertEquals(false, newTask.isScheduledTask());
		assertEquals(COMMAND_TYPE.ADD_TASK, cmd.getCommandType());
		assertEquals("Meet ABCD 16", newTask.getDescription());
	}

	@Test
	public void checkGetParsedCommand3() throws Exception {
		String testString = "-  16";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.DELETE_TASK, cmd.getCommandType());
		String output = "";
		for (int x : cmd.getIndexList()) {
			output += x;
		}
		
		assertEquals("16", output);
		assertEquals(null, cmd.getTaskDetails());
	}

	@Test
	public void checkGetParsedCommand4() throws Exception {
		String testString = "done  16";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.COMPLETE_TASK, cmd.getCommandType());
		String output = "";
		for (int x : cmd.getIndexList()) {
			output += x;
		}
		assertEquals("16", output);
		assertEquals(null, cmd.getTaskDetails());
	}

	@Test
	public void checkGetParsedCommand5() throws Exception {
		String testString = "edit  16  21/3/16";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.MODIFY_TASK, cmd.getCommandType());
		String output = "";
		for (int x : cmd.getIndexList()) {
			output += x;
		}
		assertEquals("16", output);
		Task newTask = cmd.getTaskDetails();
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(false, newTask.isScheduledTask());
		assertEquals("21/3/16", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());

	}

	@Test
	public void checkGetParsedCommand6() throws Exception {
		String testString = "e  16  21/3/16 600";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.MODIFY_TASK, cmd.getCommandType());
		String output = "";
		for (int x : cmd.getIndexList()) {
			output += x;
		}
		assertEquals("16", output);
		Task newTask = cmd.getTaskDetails();
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(false, newTask.isScheduledTask());
		assertEquals("21/3/16 600", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
	}

	@Test
	public void checkGetParsedCommand7() throws Exception {
		String testString = "edit 16  600 1800";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.MODIFY_TASK, cmd.getCommandType());
		String output = "";
		for (int x : cmd.getIndexList()) {
			output += x;
		}
		assertEquals("16", output);
		Task newTask = cmd.getTaskDetails();
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(false, newTask.isScheduledTask());
		assertEquals("600 1800", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
	}

	@Test
	public void checkGetParsedCommand8() throws Exception {
		String testString = "edit  16  21/3/16 600 1800 submit work";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.MODIFY_TASK, cmd.getCommandType());
		String output = "";
		for (int x : cmd.getIndexList()) {
			output += x;
		}
		assertEquals("16", output);
		Task newTask = cmd.getTaskDetails();
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(false, newTask.isScheduledTask());
		assertEquals("21/3/16 600 1800 submit work", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
	}

	@Test
	public void checkGetParsedCommand9() throws Exception {
		try {
			String testString = "del 5";
			Command cmd = CommandParser.getParsedCommand(testString);
			assertEquals(COMMAND_TYPE.DELETE_TASK, cmd.getCommandType());
			String output = "";
			for (int x : cmd.getIndexList()) {
				output += x;
			}
			assertEquals("5", output);
			assertEquals(null, cmd.getTaskDetails());
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	@Test
	public void checkGetParsedCommand10() throws Exception {
		String testString = "add hello 1030";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.ADD_TASK, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals("hello", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		// assertEquals("2016-03-07", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals("10:30", newTask.getEndTime().toString());
	}

	@Test
	public void checkGetParsedCommand11() throws Exception {
		String testString = "undone 11, 13, 12-17";
		String output = "";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.INCOMPLETE_TASK, cmd.getCommandType());
		for (int x : cmd.getIndexList()) {
			output += x;
		}
		assertEquals("11121314151617", output);
		assertEquals(null, cmd.getTaskDetails());
	}

	@Test
	public void checkGetParsedCommand12() throws Exception {
		String testString = "set timetable";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.ADD_TASK, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals("set timetable", newTask.getDescription());
		assertEquals(true, newTask.isFloatingTask());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
	}

	/**
	 * Boundary testing for undo. In spite of additional string, detects it as
	 * undo command.
	 * 
	 * @throws Exception
	 */
	@Test
	public void checkGetParsedCommand13() throws Exception {
		String testString = "undo extra stuff";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.UNDO_TASK, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		assertEquals(null, cmd.getTaskDetails());
	}

	/**
	 * Boundary testing for redo. In spite of additional string, detects it as
	 * undo command.
	 * 
	 * @throws Exception
	 */
	@Test
	public void checkGetParsedCommand14() throws Exception {
		String testString = "redo    12   121  extra stuff";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.REDO_TASK, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		assertEquals(null, cmd.getTaskDetails());
	}

	/**
	 * Boundary testing for home view. In spite of additional string, detects it
	 * as undo command.
	 * 
	 * @throws Exception
	 */
	@Test
	public void checkGetParsedCommand15() throws Exception {
		String testString = "home  12   121  extra stuff";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.HOME, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		assertEquals(null, cmd.getTaskDetails());
	}

	/**
	 * Viewing overdue tasks
	 * 
	 * @throws Exception
	 */
	@Test
	public void checkGetParsedCommand16() throws Exception {
		String testString = "view  overdue  ";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.VIEW_LIST, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals(LocalDate.MIN, newTask.getStartDate());
		assertEquals(LocalDate.now(), newTask.getEndDate());
		// assertEquals(LocalTime.now().truncatedTo(ChronoUnit.MINUTES),
		// newTask.getEndTime().truncatedTo(ChronoUnit.MINUTES));
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetParsedCommand17() throws Exception {
		String testString = "help    ";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.HELP, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		assertEquals(null, cmd.getTaskDetails());
	}

	@Test
	public void checkGetParsedCommand18() throws Exception {
		String testString = "help  Jim with German  ";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.ADD_TASK, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals("Help Jim with German", newTask.getDescription());
		assertEquals(true, newTask.isFloatingTask());
		assertEquals(false, newTask.isComplete());
	}

	/**
	 * Boundary test case to check if add throws an exception with blank
	 * description.
	 */
	@Test
	public void checkGetParsedCommand19() {
		String testString = "add  ";
		boolean isException = true;
		try {
			CommandParser.getParsedCommand(testString);
			isException = false;
		} catch (Exception e) {
			assertEquals(true, isException);
		}
		assertEquals(true, isException);
	}

	@Test
	public void checkGetParsedCommand20() throws Exception {
		String testString = " view  Jan  ";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.VIEW_LIST, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals("Jan", newTask.getDescription());
		assertEquals("2017-01-01", newTask.getStartDate().toString());
		assertEquals("2017-01-31", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());

	}

	@Test
	public void checkGetParsedCommand21() throws Exception {
		String testString = " add lessons from 23may to 10pm 25 may  ";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.ADD_TASK, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals("lessons", newTask.getDescription());
		assertEquals("2016-05-23", newTask.getStartDate().toString());
		assertEquals("2016-05-25", newTask.getEndDate().toString());
		assertEquals(LocalTime.MAX, newTask.getStartTime());
		assertEquals(LocalTime.of(22, 00), newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetParsedCommand22() throws Exception {
		String testString = " search 5 days  ";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.SEARCH_TASK, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals("5 days", newTask.getDescription());
		assertEquals(LocalDate.now(), newTask.getStartDate());
		assertEquals(LocalDate.now().plusDays(5), newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetParsedCommand23() throws Exception {
		String testString = " view   archive  ";
		Command cmd = CommandParser.getParsedCommand(testString);
		assertEquals(COMMAND_TYPE.VIEW_LIST, cmd.getCommandType());
		assertEquals(null, cmd.getIndexList());
		Task newTask = cmd.getTaskDetails();
		assertEquals("archive", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(true, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria1() throws Exception {
		String testString = "this week";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("this week", newTask.getDescription());
		assertEquals("2016-04-10", newTask.getStartDate().toString());
		assertEquals("2016-04-17", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria2() throws Exception {
		String testString = "next week";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("next week", newTask.getDescription());
		assertEquals("2016-04-17", newTask.getStartDate().toString());
		assertEquals("2016-04-24", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria3() throws Exception {
		String testString = "this  month  ";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("this month", newTask.getDescription());
		assertEquals("2016-04-01", newTask.getStartDate().toString());
		assertEquals("2016-04-30", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria4() throws Exception {
		String testString = "next month";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("next month", newTask.getDescription());
		assertEquals("2016-05-01", newTask.getStartDate().toString());
		assertEquals("2016-05-31", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria5() throws Exception {
		String testString = "this  year  ";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("this year", newTask.getDescription());
		assertEquals("2016-01-01", newTask.getStartDate().toString());
		assertEquals("2016-12-31", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria6() throws Exception {
		String testString = "next year";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("next year", newTask.getDescription());
		assertEquals("2017-01-01", newTask.getStartDate().toString());
		assertEquals("2017-12-31", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria7() throws Exception {
		String testString = "today";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("today", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(LocalDate.now(), newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria8() throws Exception {
		String testString = "tomorrow";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("tomorrow", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(LocalDate.now().plusDays(1), newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria9() throws Exception {
		String testString = "complete";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("complete", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria10() throws Exception {
		String testString = "21/12/12/12";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("21/12/12/12", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria11() throws Exception {
		String testString = "NOV";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("NOV", newTask.getDescription());
		assertEquals("2016-11-01", newTask.getStartDate().toString());
		assertEquals("2016-11-30", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria12() throws Exception {
		String testString = "february";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("february", newTask.getDescription());
		assertEquals("2017-02-01", newTask.getStartDate().toString());
		assertEquals("2017-02-28", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria13() throws Exception {
		String testString = "21/12/12";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("21/12/12", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals("2012-12-21", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria14() throws Exception {
		String testString = "21aug";
		Task newTask = CommandParser.getCriteria(testString);
		assertEquals("21aug", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals("2016-08-21", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	@Test
	public void checkGetCriteria15() throws Exception {
		String testString = " next  3days";
		Task newTask = CommandParser.getCriteria(testString);
		// assertEquals("", newTask.getDescription());
		assertEquals(LocalDate.now(), newTask.getStartDate());
		assertEquals(LocalDate.now().plusDays(3), newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
	}

	// Convert Scheduled to Floating; remove date from task
	@Test
	public void checkEditExistingTask1() throws Exception {
		Task oldTask = new Task("buy dog", null, LocalDate.parse("2016-08-08"), null, LocalTime.MAX);
		oldTask.setScheduledTask();
		String testString = "del dates";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());
		assertEquals(null, newTask.getStartTime());
		assertEquals(null, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(true, newTask.isFloatingTask());
		assertEquals(false, newTask.isScheduledTask());
	}

	// Remove Time from Task
	@Test
	public void checkEditExistingTask2() throws Exception {
		Task oldTask = new Task("buy dog", null, LocalDate.parse("2016-08-08"), null, LocalTime.MAX);
		oldTask.setScheduledTask();
		String testString = "del times";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals("2016-08-08", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	// Convert Floating to Scheduled
	@Test
	public void checkEditExistingTask3() throws Exception {
		Task oldTask = new Task("buy dog", null, null, null, null);
		oldTask.setFloatingTask();
		String testString = "23 Feb 2017";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals("2017-02-23", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	// Convert Floating to Scheduled
	@Test
	public void checkEditExistingTask4() throws Exception {
		Task oldTask = new Task("buy dog", null, null, null, null);
		oldTask.setFloatingTask();
		String testString = "23/2/17";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals("2017-02-23", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask5() throws Exception {
		Task oldTask = new Task("buy dog", null, null, null, null);
		oldTask.setFloatingTask();
		String testString = "23/2/17 25/2/17";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals("2017-02-23", newTask.getStartDate().toString());
		assertEquals("2017-02-25", newTask.getEndDate().toString());
		assertEquals(LocalTime.MAX, newTask.getStartTime());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask6() throws Exception {
		Task oldTask = new Task("buy dog", null, null, null, null);
		oldTask.setFloatingTask();
		String testString = "23/2/17 25/2/17 5pm";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals("2017-02-23", newTask.getStartDate().toString());
		assertEquals("2017-02-25", newTask.getEndDate().toString());
		assertEquals("17:00", newTask.getStartTime().toString());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask7() throws Exception {
		Task oldTask = new Task("buy dog", LocalDate.parse("2016-06-08"), LocalDate.parse("2016-08-08"),
				LocalTime.parse("12:00"), LocalTime.parse("16:00"));
		oldTask.setScheduledTask();
		String testString = "3pm 5pm";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals("2016-06-08", newTask.getStartDate().toString());
		assertEquals("2016-08-08", newTask.getEndDate().toString());
		assertEquals("15:00", newTask.getStartTime().toString());
		assertEquals("17:00", newTask.getEndTime().toString());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask8() throws Exception {
		Task oldTask = new Task("buy dog", LocalDate.parse("2016-06-08"), LocalDate.parse("2016-08-08"),
				LocalTime.parse("12:00"), LocalTime.parse("16:00"));
		oldTask.setScheduledTask();
		String testString = "d times";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals("2016-06-08", newTask.getStartDate().toString());
		assertEquals("2016-08-08", newTask.getEndDate().toString());
		assertEquals(LocalTime.MAX, newTask.getStartTime());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask9() throws Exception {
		Task oldTask = new Task("buy dog", LocalDate.parse("2016-06-08"), LocalDate.parse("2016-08-08"),
				LocalTime.parse("12:00"), LocalTime.parse("16:00"));
		oldTask.setScheduledTask();
		String testString = "from 4pm to 10pm on 23apr";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals("2016-04-23", newTask.getStartDate().toString());
		assertEquals("2016-04-23", newTask.getEndDate().toString());
		assertEquals("16:00", newTask.getStartTime().toString());
		assertEquals("22:00", newTask.getEndTime().toString());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask10() throws Exception {
		Task oldTask = new Task("buy dog", LocalDate.parse("2016-06-08"), LocalDate.parse("2016-08-08"),
				LocalTime.parse("12:00"), LocalTime.parse("12:00"));
		oldTask.setScheduledTask();
		String testString = " 23apr";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals("2016-04-23", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(LocalTime.MAX, newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask11() throws Exception {
		Task oldTask = new Task("buy dog", LocalDate.parse("2016-06-08"), LocalDate.parse("2016-08-08"),
				LocalTime.parse("12:00"), LocalTime.parse("12:00"));
		oldTask.setScheduledTask();
		String testString = " 23apr to 19apr";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals(LocalDate.of(2016, 04, 19), newTask.getStartDate());
		assertEquals("2016-04-23", newTask.getEndDate().toString());
		assertEquals(LocalTime.of(12, 0), newTask.getStartTime());
		assertEquals(LocalTime.of(12, 0), newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkEditExistingTask12() throws Exception {
		Task oldTask = new Task("buy dog", LocalDate.parse("2016-06-08"), LocalDate.parse("2016-08-08"),
				LocalTime.parse("12:00"), LocalTime.parse("12:00"));
		oldTask.setScheduledTask();
		String testString = " 23apr to 23apr";
		Task newTask = CommandParser.editExistingTask(oldTask, testString);
		assertEquals("buy dog", newTask.getDescription());
		assertEquals(null, newTask.getStartDate());
		assertEquals("2016-04-23", newTask.getEndDate().toString());
		assertEquals(null, newTask.getStartTime());
		assertEquals(LocalTime.of(12, 0), newTask.getEndTime());
		assertEquals(false, newTask.isComplete());
		assertEquals(false, newTask.isFloatingTask());
		assertEquals(true, newTask.isScheduledTask());
	}

	@Test
	public void checkSetDir() {
		Task task = new Task();
		String testString = "C:\\\\SH";
		task = CommandParser.setDirectory(new Command(), testString);
		assertEquals("C:\\\\SH", task.getDescription());
	}
}
```
###### \Parser\DateParser.java
``` java

package Parser;

import java.util.ArrayList;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.text.ParsePosition;
import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.MonthDay;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;

/*
 * DateParser is used to detect all possible dates in a String, 
 * add it to the dateList, 
 * and remove it from the taskDetails.
 * 
 * Thus aiding in parsing the given String input.
 */
public class DateParser {

	// Instance Variables
	private String taskDetails;
	private ArrayList<LocalDate> dateList = new ArrayList<LocalDate>();

	/****************** CONSTRUCTORS **********************/
	DateParser() {
		this(ParserConstants.STRING_EMPTY, new ArrayList<LocalDate>());
	}

	DateParser(String newTaskDetails) {
		this(newTaskDetails, new ArrayList<LocalDate>());
	}

	DateParser(String newTaskDetails, ArrayList<LocalDate> newDateList) {
		setTaskDetails(newTaskDetails);
		setDateList(newDateList);
	}

	/****************** SETTER METHODS ***********************/
	protected void setTaskDetails(String newTaskDetails) {
		this.taskDetails = cleanupExtraWhitespace(newTaskDetails);
	}

	protected void setDateList(ArrayList<LocalDate> dateList) {
		this.dateList = dateList;
	}

	/****************** GETTER METHODS ***********************/
	public String getTaskDetails() {
		return cleanupExtraWhitespace(this.taskDetails);
	}

	ArrayList<LocalDate> getDateList() {
		if (dateList.isEmpty()) {
			return null;
		}
		return this.dateList;
	}

	/****************** OTHER METHODS ***********************/

	/**
	 * This method is used to extract all the dates from taskDetails
	 */
	public void findDates() {
		String taskDetails = getTaskDetails();
		String previousWord = ParserConstants.STRING_EMPTY;
		int startPrevWord = ParserConstants.FIRST_INDEX;

		Pattern datePattern = Pattern.compile(ParserConstants.REGEX_POSSIBLE_DATE);
		Matcher dateMatcher = datePattern.matcher(taskDetails);

		while (dateMatcher.find()) {
			try {
				previousWord = taskDetails.substring(startPrevWord, dateMatcher.start());
				String tempString = cleanupExtraWhitespace(taskDetails.substring(dateMatcher.start()));
				if (!addToListIfValidDate(tempString, previousWord)) {
					String firstWord = cleanupExtraWhitespace(getFirstXWords(tempString, 1));
					if (isDayOfWeek(firstWord)) {
						firstWord = getStartString(firstWord);
						if (taskDetailsContains(firstWord)) {
							dateList.add(getDayOfWeekDate(firstWord));
							if (isValidKeyWord(previousWord) || isValidRangeKeyWord(previousWord)) {
								removeDateFromTaskDetails(previousWord + ParserConstants.STRING_WHITESPACE + firstWord);
							} else {
								removeDateFromTaskDetails(firstWord);
							}
						}
					} else if (isUpcomingDayString(tempString)) {
						String upcomingDay = getUpComingDayWord(tempString);
						if (taskDetailsContains(upcomingDay)) {
							dateList.add(getUpcomingDayDate(upcomingDay));
							if (isValidKeyWord(previousWord) || isValidRangeKeyWord(previousWord)) {
								removeDateFromTaskDetails(
										previousWord + ParserConstants.STRING_WHITESPACE + upcomingDay);
							} else {
								removeDateFromTaskDetails(upcomingDay);
							}
						}
					} else if (hasDayDuration(tempString)) {
						String dayDuration = getDayDurationWord(tempString);
						if (taskDetailsContains(dayDuration)) {
							dateList.add(getParsedDayDurationDate(tempString));
							if (isValidKeyWord(previousWord) || isValidRangeKeyWord(previousWord)) {
								removeDateFromTaskDetails(
										previousWord + ParserConstants.STRING_WHITESPACE + dayDuration);
							} else {
								removeDateFromTaskDetails(dayDuration);
							}
						}
					}
				}
				startPrevWord = dateMatcher.start();
			} catch (Exception e) {
				// do nothing
			}
		}
	}

	/**
	 * This method removes the particular textToRemove from taskDetails.
	 * 
	 * @param textToRemove
	 */
	public void removeDateFromTaskDetails(String textToRemove) {
		textToRemove = cleanupExtraWhitespace(textToRemove);
		if (taskDetails.startsWith(textToRemove)) {
			taskDetails = CommandParser
					.cleanupExtraWhitespace(taskDetails.replaceFirst(textToRemove, ParserConstants.STRING_WHITESPACE));
		} else {
			taskDetails = CommandParser.cleanupExtraWhitespace(taskDetails
					.replaceFirst(ParserConstants.STRING_WHITESPACE + textToRemove, ParserConstants.STRING_WHITESPACE));
		}
	}

	/**
	 * This method checks if the immediate String contains a date. If it is a
	 * Valid Date, it adds it to the List.
	 * 
	 * @param statement
	 * @param keyword
	 * @return true, if the immediate String is a valid date; otherwise false.
	 */
	public boolean addToListIfValidDate(String statement, String keyword) {
		String tempStatement = statement;
		String end = ParserConstants.STRING_EMPTY;
		statement = cleanupExtraWhitespace(statement);
		for (DateTimeFormatter format : generateDateFormatList()) {
			DateTimeFormatter myFormatter = new DateTimeFormatterBuilder().parseCaseInsensitive().append(format)
					.toFormatter(Locale.ENGLISH);
			try {
				ParsePosition index = new ParsePosition(ParserConstants.FIRST_INDEX);
				LocalDate parsedDate = LocalDate.from(myFormatter.parse(statement.trim(), index));
				if (index.getIndex() < statement.length()) {
					end = statement.substring(index.getIndex());
				}

				statement = statement.substring(ParserConstants.FIRST_INDEX, index.getIndex());

				if (taskDetailsContains(statement) && isValidEnd(end)) {
					addDateToList(parsedDate);
					if (isValidKeyWord(keyword) || isValidRangeKeyWord(keyword)) {
						removeDateFromTaskDetails(keyword + ParserConstants.STRING_WHITESPACE + statement);
					} else {
						removeDateFromTaskDetails(statement);
					}
					return true;
				}
			} catch (IndexOutOfBoundsException e) {
				// do nothing
			} catch (DateTimeParseException e) {
				// do nothing
			} catch (DateTimeException e) {
				// do nothing
			}
		}
		if (addToListIfValidDateWithoutYear(tempStatement, keyword)) {
			return true;
		}
		return false;
	}

	/**
	 * This method is used to check if statement starts with a possible date
	 * format, without a year. That is, only month and day are specified.
	 * 
	 * @param statement
	 *            to check if starts with a possible date
	 * @param keyword
	 *            to check if it is a date keyword, and remove it in the case.
	 * @return true, if statement starts with a word, otherwise false.
	 */
	public boolean addToListIfValidDateWithoutYear(String statement, String keyword) {
		String end = ParserConstants.STRING_EMPTY;
		statement = cleanupExtraWhitespace(statement);
		for (DateTimeFormatter format : generateDateFormatListWithoutYear()) {
			DateTimeFormatter myFormatter = new DateTimeFormatterBuilder().parseCaseInsensitive().append(format)
					.toFormatter(Locale.ENGLISH);
			try {
				ParsePosition index = new ParsePosition(ParserConstants.FIRST_INDEX);
				MonthDay monthDay = MonthDay.from(myFormatter.parse(statement.trim(), index));
				LocalDate parsedDate = monthDay.atYear(getCurrentYear());
				if (parsedDate.isBefore(getTodayDate())) {
					parsedDate = parsedDate.plusYears(ParserConstants.ONE_YEAR);
				}
				if (index.getIndex() < statement.length()) {
					end = statement.substring(index.getIndex());
				}

				statement = statement.substring(ParserConstants.FIRST_INDEX, index.getIndex());

				// if the date located is contained in taskDetails(to ensure
				// that random dates are not detected)
				// and if the date string detected ends with either a
				// fullstop(.) or a comma (,) or a space or marks the end of the
				// sentence.
				if (taskDetailsContains(statement) && isValidEnd(end)) {
					addDateToList(parsedDate);
					if (isValidKeyWord(keyword) || isValidRangeKeyWord(keyword)) {
						removeDateFromTaskDetails(keyword + ParserConstants.STRING_WHITESPACE + statement);
					} else {
						removeDateFromTaskDetails(statement);
					}
					return true;
				}
			} catch (IndexOutOfBoundsException e) {
				// do nothing
			} catch (DateTimeParseException e) {
				// do nothing
			} catch (DateTimeException e) {
				// do nothing
			}
		}
		return false;
	}

	/**
	 * This method is used to determine the date of the upcoming day of the
	 * week.
	 * 
	 * @param dayOfWeek
	 *            of which date is supposed to be determined.
	 * @return date of the given dayOfWeek.
	 */
	public LocalDate getDayOfWeekDate(String dayOfWeek) {

		dayOfWeek = getStartString(dayOfWeek);
		assert isDayOfWeek(dayOfWeek);

		LocalDate newDate = getTodayDate();

		int dayOfWeekNumToday = newDate.getDayOfWeek().getValue();
		int dayOfWeekValue = indexOf(dayOfWeek, ParserConstants.DAYS_OF_WEEK_LONG);
		if (dayOfWeekValue < 0) {
			dayOfWeekValue = indexOf(dayOfWeek, ParserConstants.DAYS_OF_WEEK_SHORT);
		}
		if (dayOfWeekValue < 0) {
			dayOfWeekValue = indexOf(dayOfWeek, ParserConstants.DAYS_OF_WEEK_MEDIUM);
		}
		int daysToAdd = dayOfWeekValue - dayOfWeekNumToday;
		if (daysToAdd <= 0) {
			daysToAdd += ParserConstants.DAYS_IN_WEEK;
		}
		newDate = newDate.plusDays(daysToAdd);

		return newDate;
	}

	public boolean isDayOfWeek(String expectedDayOfWeek) {
		expectedDayOfWeek = getStartString(expectedDayOfWeek);

		return (isDayOfWeekLong(expectedDayOfWeek) || isDayOfWeekShort(expectedDayOfWeek)
				|| isDayOfWeekMedium(expectedDayOfWeek)) && isValidEnd(getEnd(expectedDayOfWeek));
	}

	/**
	 * This method checks if statement contains a day of the week which is
	 * written in full form
	 * 
	 * @param statement
	 * @return true if is either of {"monday", "tuesday", "wednesday",
	 *         "thursday", "friday", "saturday", "sunday"}; false, otherwise
	 */
	public boolean isDayOfWeekLong(String expectedDayOfWeek) {
		return hasInDictionary(ParserConstants.DAYS_OF_WEEK_LONG, expectedDayOfWeek);
	}

	public boolean isDayOfWeekMedium(String expectedDayOfWeek) {
		return hasInDictionary(ParserConstants.DAYS_OF_WEEK_MEDIUM, expectedDayOfWeek);
	}

	/**
	 * This method checks if statement contains a day of the week written in
	 * short
	 * 
	 * @param statement
	 * @return true if is either of { "mon", "tue", "wed", "thu", "fri", "sat",
	 *         "sun" } ;false, otherwise
	 */
	public boolean isDayOfWeekShort(String expectedDayOfWeek) {
		return hasInDictionary(ParserConstants.DAYS_OF_WEEK_SHORT, expectedDayOfWeek);
	}

	/**
	 * This method is used to convert today, tomorrow and overmorrow to their
	 * respective dates
	 * 
	 * @param upcomingDay
	 * @return LocalDate of the upcomingDay relative to today's date
	 */
	public LocalDate getUpcomingDayDate(String upcomingDay) {
		LocalDate todayDate = getTodayDate();
		int index = indexOf(upcomingDay, ParserConstants.UPCOMING_DAYS);
		if (index >= 0) { /* If upcomingDay is a valid entry */
			index /= 2;
			if (index < 1) {
				return todayDate;
			} else if (index < 3) {
				return todayDate.plusDays(1);
			} else {
				return todayDate.plusDays(2);
			}
		}
		return null;
	}

	/**
	 * Today, tomorrow, day after tomorrow and the like account for upcoming
	 * days. This method checks if textToFind starts with an upcoming day word.
	 * 
	 * @param textToFind
	 * @return true, if textToFind starts with an upcoming day word; false
	 *         otherwise.
	 */
	public boolean isUpcomingDayString(String textToFind) {
		if (textToFind != null && !textToFind.isEmpty()) {
			String firstWord = getFirstXWords(textToFind, ParserConstants.ONE_WORD);
			String firstThreeWords = getFirstXWords(textToFind, ParserConstants.THREE_WORDS);

			return (hasInDictionary(ParserConstants.UPCOMING_DAYS, getStartString(firstWord))
					&& isValidEnd(getEnd(firstWord)))
					|| (hasInDictionary(ParserConstants.UPCOMING_DAYS, getStartString(firstThreeWords))
							&& isValidEnd(getEnd(firstThreeWords)));
		}
		return false;
	}

	/**
	 * This method extracts the upcoming day word from the given String
	 * textToFind.
	 * 
	 * @param textToFind
	 * @return the upcoming day word from textToFind.
	 */
	public String getUpComingDayWord(String textToFind) {
		String firstWord = getStartString(getFirstXWords(textToFind, ParserConstants.ONE_WORD));
		String firstThreeWords = getStartString(getFirstXWords(textToFind, ParserConstants.THREE_WORDS));

		if (hasInDictionary(ParserConstants.UPCOMING_DAYS, firstWord)) {
			return firstWord;
		} else if (hasInDictionary(ParserConstants.UPCOMING_DAYS, firstThreeWords)) {
			return firstThreeWords;
		}

		return null;
	}

	public LocalDate getParsedDayDurationDate(String text) {
		try {
			String firstWord = ParserConstants.STRING_EMPTY;
			String secondWord = ParserConstants.STRING_EMPTY;
			if (isFirstWordDayDuration(text)) {
				int splitPos = -1;
				for (int index = ParserConstants.FIRST_INDEX; index < text.length(); index++) {
					if (!Character.isDigit(text.charAt(index))) {
						splitPos = index;
						break;
					}
				}
				secondWord = text.substring(splitPos);
				firstWord = text.substring(ParserConstants.FIRST_INDEX, splitPos);
			} else {
				firstWord = getFirstXWords(text, ParserConstants.ONE_WORD);
				secondWord = text.replace(firstWord, ParserConstants.STRING_WHITESPACE).trim();
			}
			LocalDate parsedDate = getDayDurationDate(firstWord, secondWord);
			return parsedDate;
		} catch (Exception e) {
			// no exception encountered, just a precaution
		}
		return null;
	}

	/**
	 * This method extracts the day duration word from the given textToSearch.
	 * 
	 * @param textToSearch
	 * @return day duration word from textToSearch.
	 */
	public String getDayDurationWord(String textToSearch) {
		String firstWord = getStartString(getFirstXWords(textToSearch, ParserConstants.ONE_WORD));

		if (isFirstWordDayDuration(textToSearch)) {
			return firstWord;
		} else {
			return getStartString(getFirstXWords(textToSearch, ParserConstants.TWO_WORDS));
		}
	}

	public LocalDate getDayDurationDate(String firstWord, String secondWord) {
		LocalDate parsedDate = getTodayDate();
		int unitsToAdd = Integer.parseInt(firstWord);
		int indexOfKeyword = indexOf(secondWord, ParserConstants.DAY_DURATION);

		if (indexOfKeyword <= ParserConstants.LAST_INDEX_OF_DAY) {
			parsedDate = parsedDate.plusDays(unitsToAdd);
		} else if (indexOfKeyword <= ParserConstants.LAST_INDEX_OF_WEEK) {
			parsedDate = parsedDate.plusWeeks(unitsToAdd);
		} else if (indexOfKeyword <= ParserConstants.LAST_INDEX_OF_MONTH) {
			parsedDate = parsedDate.plusMonths(unitsToAdd);
		} else {
			parsedDate = parsedDate.plusYears(unitsToAdd);
		}
		return parsedDate;
	}

	/**
	 * Day duration refers to a number followed by either days, weeks, months or
	 * years. The digit and the String may or may not have a whitespace in
	 * between.
	 * 
	 * @param tempString
	 * @return true if tempString starts with a day duration word; false
	 *         otherwise.
	 */
	public boolean hasDayDuration(String tempString) {
		try {
			return isFirstWordDayDuration(tempString) || isFirstTwoWordsDayDuration(tempString);
		} catch (NullPointerException e) {
			// do nothing
		} catch (NumberFormatException e) {
			// do nothing
		} catch (IndexOutOfBoundsException e) {
			// do nothing
		}
		return false;
	}

	/**
	 * This method is used to check if the first word of inputString is a day
	 * duration word.
	 * 
	 * @param inputString
	 * @return true if inputString first word is day duration; false otherwise.
	 * @throws NullPointerException
	 * @throws NumberFormatException
	 * @throws IndexOutOfBoundsException
	 */
	public boolean isFirstWordDayDuration(String inputString)
			throws NullPointerException, NumberFormatException, IndexOutOfBoundsException {
		String firstWord = getFirstXWords(inputString, ParserConstants.ONE_WORD);
		String endString = getEnd(firstWord);
		firstWord = getStartString(firstWord);

		if (firstWord.matches(ParserConstants.REGEX_POSSIBLE_DURATION)) {
			int splitPos = -1;
			for (int index = ParserConstants.FIRST_INDEX; index < firstWord.length(); index++) {
				if (!Character.isDigit(firstWord.charAt(index))) {
					splitPos = index;
					break;
				}
			}
			String secondWord = firstWord.substring(splitPos);
			firstWord = firstWord.substring(ParserConstants.FIRST_INDEX, splitPos);
			if (hasInDictionary(ParserConstants.DAY_DURATION, secondWord) && isValidEnd(endString)) {
				Integer.parseInt(firstWord);
				return true;
			}
		}
		return false;
	}

	/**
	 * This method is used to check the first two words of inputString for
	 * occurrence of day duration.
	 * 
	 * @param inputString
	 * @return true if first two words mark day duration; false otherwise.
	 * @throws NullPointerException
	 * @throws NumberFormatException
	 */
	public boolean isFirstTwoWordsDayDuration(String inputString) throws NullPointerException, NumberFormatException {
		String firstWord = getFirstXWords(inputString, ParserConstants.ONE_WORD);
		String first2Words = getFirstXWords(inputString, ParserConstants.TWO_WORDS);
		String secondWord = first2Words.replace(firstWord, ParserConstants.STRING_WHITESPACE).trim();
		String endString = getEnd(secondWord);

		if (hasInDictionary(ParserConstants.DAY_DURATION, getStartString(secondWord)) && isValidEnd(endString)) {
			Integer.parseInt(firstWord);
			return true;
		}
		return false;
	}

	public boolean isMonth(String firstWord) {
		firstWord = getStartString(firstWord);
		return hasInDictionary(ParserConstants.MONTHS_LONG, firstWord)
				|| hasInDictionary(ParserConstants.MONTHS_SHORT, firstWord);
	}

	public int getMonthNum(String month) {
		month = getStartString(month);
		if (hasInDictionary(ParserConstants.MONTHS_LONG, month)) {
			return indexOf(month, ParserConstants.MONTHS_LONG);
		} else if (hasInDictionary(ParserConstants.MONTHS_SHORT, month)) {
			return indexOf(month, ParserConstants.MONTHS_SHORT);
		} else {
			return ParserConstants.DEFAULT_INDEX_NUMBER;
		}
	}

	public int getCurrentYear() {
		LocalDate today = LocalDate.now();
		return today.getYear();
	}

	public LocalDate getTodayDate() {
		return LocalDate.now();
	}

	/**
	 * This method returns the first occurrence of word in array[].
	 * 
	 * @param word
	 * @param array
	 * @return return the first index of word if it is present in array[];
	 *         otherwise -1.
	 */
	public int indexOf(String word, String[] array) {
		if (hasInDictionary(array, word)) {
			for (int index = ParserConstants.FIRST_INDEX; index < array.length; index++) {
				if (word.equalsIgnoreCase(array[index])) {
					return index;
				}
			}
		}
		return ParserConstants.DEFAULT_INDEX_NUMBER; // if absent
	}

	public void addDateToList(LocalDate parsedDate) {
		dateList.add(parsedDate);
	}

	/**
	 * Dates can have a comprehensive list of keywords from { "by", "on", "in",
	 * "before", "from", "frm" } preceding them. This method checks if "keyword"
	 * contains any of these date keywords.
	 * 
	 * @param keyword
	 * @return true if it is a valid date keyword; false otherwise.
	 */
	public boolean isValidKeyWord(String keyword) {
		return hasInDictionary(ParserConstants.DATE_KEYWORD, keyword.trim());
	}

	/**
	 * "to" and hyphen "-" are the range keywords. This method checks if keyword
	 * is a valid range keyword.
	 * 
	 * @param keyword
	 * @return return true if keyword equals "to" or "-"; false otherwise.
	 */
	public boolean isValidRangeKeyWord(String keyword) {
		if (keyword == null || keyword.isEmpty()) {
			return false;
		} else {
			keyword = keyword.trim();
			return (keyword.equalsIgnoreCase(ParserConstants.STRING_HYPHEN)
					|| keyword.equalsIgnoreCase(ParserConstants.STRING_TO))
					&& (dateList.size() > ParserConstants.MIN_SIZE);
		}
	}

	/**
	 * A valid end is denoted by a String that ends with a period, comma,
	 * whitespace or is the end of the String.
	 * 
	 * @param endText
	 *            to check if its end is valid.
	 * @return true if endText has valid end; false otherwise.
	 */
	private boolean isValidEnd(String endText) {
		if (endText.isEmpty()) {
			return true;
		}
		String firstCharacter = endText.charAt(ParserConstants.FIRST_INDEX) + ParserConstants.STRING_EMPTY;
		return hasInDictionary(ParserConstants.VALID_END, firstCharacter);
	}

	/**
	 * This method is used to find the end of the String text from the first
	 * occurrence of a non-word character.
	 * 
	 * @param text
	 * @return substring of text, starting from first non-word character until
	 *         the end of text. If no non-word character present, returns an
	 *         empty String.
	 */
	private String getEnd(String text) {
		int indexOfNonWord = getIndexOfNonWordChar(text);
		if (indexOfNonWord > ParserConstants.DEFAULT_INDEX_NUMBER) {
			return text.substring(indexOfNonWord);
		}
		return ParserConstants.STRING_EMPTY;
	}

	/**
	 * This method substring text, until the first occurrence of a non-word
	 * character.
	 * 
	 * @param text
	 * @return substring of text from index 0 until the first occurrence of
	 *         non-word character.
	 */
	private String getStartString(String text) {
		int indexOfNonWord = getIndexOfNonWordChar(text);
		if (indexOfNonWord > ParserConstants.DEFAULT_INDEX_NUMBER) {
			return text.substring(ParserConstants.FIRST_INDEX, indexOfNonWord);
		}
		return text;
	}

	/**
	 * This method checks if any index of dictionary[] equals the wordsToFind
	 * (case insensitive).
	 * 
	 * @param dictionary
	 * @param wordsToFind
	 * @return true if dictionary contains wordToFind; false otherwise.
	 */
	private boolean hasInDictionary(String[] dictionary, String wordsToFind) {
		if (wordsToFind != null && !wordsToFind.isEmpty()) {
			for (String dictionaryWords : dictionary) {
				if (dictionaryWords.equalsIgnoreCase(wordsToFind))
					return true;
			}
		}
		return false;
	}

	public boolean taskDetailsContains(String text) {
		Pattern containPattern = Pattern.compile(ParserConstants.REGEX_VALID_START + text);
		Matcher containMatcher = containPattern.matcher(taskDetails);
		if (containMatcher.find()) {
			return true;
		}
		return false;
	}

	/**
	 * This method returns the first 'x' words from the given wordToSplit.
	 * 
	 * @param wordToSplit
	 * @param x,
	 *            number of words to return
	 * @return first x words from wordToSplit, if present; otherwise null.
	 */
	public String getFirstXWords(String wordToSplit, int x) {

		if (wordToSplit != null && !wordToSplit.isEmpty() && x > 0) {
			String[] words = wordToSplit.split(ParserConstants.STRING_WHITESPACE);

			if (words.length >= x) {
				String firstXWords = ParserConstants.STRING_EMPTY;
				for (int index = ParserConstants.FIRST_INDEX; index < x; index++) {
					firstXWords += ParserConstants.STRING_WHITESPACE + words[index];
				}
				return cleanupExtraWhitespace(firstXWords);
			}
		}

		return null;
	}

	/**
	 * This method detects the index of a non-word character in the String word.
	 * A non-word character includes everything other than an english letter, a
	 * digit and a whitespace.
	 * 
	 * @param word
	 *            is checked for any non-word character.
	 * @return index, of first non-word character in word.
	 */
	public int getIndexOfNonWordChar(String word) {
		int index = ParserConstants.DEFAULT_INDEX_NUMBER;

		if (word != null) {

			for (index = ParserConstants.FIRST_INDEX; index < word.length(); index++) {
				if (!Character.isLetterOrDigit(word.charAt(index)) && !Character.isWhitespace(word.charAt(index))) {
					break;
				}
			}

			if (index == word.length()) {
				return ParserConstants.DEFAULT_INDEX_NUMBER;
			}
		}
		return index;
	}

	/**
	 * This method removes the unnecessary white spaces present in the string.
	 * 
	 * @param someText
	 *            is any string with several white spaces.
	 * @return someText excluding the extra unnecessary white spaces.
	 */
	public String cleanupExtraWhitespace(String someText) {
		Pattern extraSpace = Pattern.compile(ParserConstants.REGEX_EXTRA_WHITESPACE);
		Matcher regexMatcher = extraSpace.matcher(someText.trim());
		String cleanText = regexMatcher.replaceAll(ParserConstants.STRING_WHITESPACE);
		return cleanText;
	}

	/**
	 * This method returns an array list of possible date formats with year.
	 * 
	 * @return dateFormatList, contains all acceptable date formats in
	 *         DateTimeFormatter type ArrayList.
	 */
	ArrayList<DateTimeFormatter> generateDateFormatList() {
		ArrayList<DateTimeFormatter> dateFormatList = new ArrayList<DateTimeFormatter>();
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_HASH_DAY_MONTH_NUM_YEAR_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_HASH_DAY_MONTH_NUM_YEAR_SHORT));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_HYPHEN_DAY_MONTH_NUM_YEAR_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_HYPHEN_DAY_MONTH_NUM_YEAR_SHORT));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_LONG_YEAR_LONG_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_LONG_YEAR_SHORT_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_SHORT_YEAR_LONG_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_SHORT_YEAR_SHORT_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_LONG_SPACE_YEAR_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_LONG_SPACE_YEAR_SHORT));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_SHORT_SPACE_YEAR_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_SHORT_SPACE_YEAR_SHORT));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_LONG_YEAR_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_LONG_YEAR_SHORT));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_SHORT_YEAR_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_SHORT_YEAR_SHORT));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_LONG_SPACE_YEAR_LONG));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_LONG_SPACE_YEAR_SHORT));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_SHORT_SPACE_YEAR_LONG));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_SPACE_MONTH_SHORT_SPACE_YEAR_SHORT));

		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_LONG_DAY_SPACE_YEAR_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_LONG_SPACE_DAY_YEAR_LONG));

		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_SHORT_DAY_SPACE_YEAR_LONG));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_SHORT_SPACE_DAY_SPACE_YEAR_LONG));

		return dateFormatList;
	}

	/**
	 * This method returns an array list of possible date formats without the
	 * year.
	 * 
	 * @return dateFormatList, contains all acceptable date formats without year
	 *         in DateTimeFormatter type ArrayList.
	 */
	ArrayList<DateTimeFormatter> generateDateFormatListWithoutYear() {
		ArrayList<DateTimeFormatter> dateFormatList = new ArrayList<DateTimeFormatter>();
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_LONG_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_SHORT_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_LONG));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_DAY_MONTH_SHORT));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_LONG_DAY_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_LONG_DAY));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_SHORT_DAY_NOSPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_MONTH_SHORT_DAY));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_HASH_DAY_MONTH_NUM));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.DATE_FORMAT_HYPHEN_DAY_MONTH_NUM));
		return dateFormatList;
	}
}
```
###### \Parser\DateParserTest.java
``` java

package Parser;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

import java.time.LocalDate;
import java.util.ArrayList;

public class DateParserTest {

	DateParser dateObj;

	@Test
	public void testIsValidDate1() {
		String testString = "3/6/2016";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate2() {
		String testString = "3 june 2016";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate3() {

		String testString = "3 June 26";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate4() {

		String testString = "28jun16";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate5() {

		String testString = "  3 june   2016";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate6() {

		String testString = "3-6-2016";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate7() {

		String testString = "3 janua 2016";
		dateObj = new DateParser(testString);
		assertEquals(false, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate8() {

		String testString = "   3 abc 2016";
		dateObj = new DateParser(testString);
		assertEquals(false, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate9() {

		String testString = "3-8-19 2016";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.addToListIfValidDate(testString, ""));
	}

	/*
	 * @Test public void testIsValidDate10() { String testString = "3-8 2016";
	 * assertEquals(true, dateObj.isValidDate(testString )); }
	 */

	@Test
	public void testIsValidDate10() {

		String testString = "3-8-19-13 2016";
		dateObj = new DateParser(testString);
		assertEquals(false, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate11() {

		String testString = "3-8-1-2016";
		dateObj = new DateParser(testString);
		assertEquals(false, dateObj.addToListIfValidDate(testString, ""));
	}

	@Test
	public void testIsValidDate12() {

		String testString = "3mar4apr";
		dateObj = new DateParser(testString);
		assertEquals(false, dateObj.addToListIfValidDateWithoutYear(testString, ""));
	}

	String[] date1 = { "22/4/2016", "22/4/16", "22/04/16", "22/04/16", "22/04", "22-4-2016", "22-4-16", "22-04-16",
			"22-04-16", "22-04", "22April2016", "22april16", "22APR2016", "22apr16", "22 April2016", "22 april16",
			"22 APR2016", "22 apr16", "22April 2016", "22april 16", "22APR 2016", "22apr 16", "22 April 2016",
			"22 april 16", "22 APR 2016", "22 apr 16", "22Apr", "22 april", "22 APR", "22april" };

	String[] date2 = { "30/8/2016", "30/8/16", "30/08/16", "30/08/16", "30/08", "30-8-2016", "30-8-16", "30-08-16",
			"30-08-16", "30-08", "30August2016", "30august16", "30AUG2016", "30aUg16", "30 August2016", "30 august16",
			"30 AUG2016", "30 aUg16", "30August 2016", "30august 16", "30AUG 2016", "30aUg 16", "30 August 2016",
			"30 august 16", "30 AUG 2016", "30 aUg 16", "30Aug", "30 august", "30 AUG", "30august" };

	String[] keyword = { "by", "on", "in", "before", "from", "frm", "" };

	@Test
	public void testDateFormat() {
		for (int index1 = 0; index1 < date1.length; index1++) {
			for (int index2 = 0; index2 < date2.length; index2++) {
				for (int index3 = 0; index3 < keyword.length; index3++) {
					dateObj = new DateParser(
							"Date format testing " + keyword[index3] + " " + date1[index1] + " to " + date2[index2]);
					dateObj.findDates();
					String output = "";
					for (LocalDate date : dateObj.getDateList()) {
						output = output + date.toString();
					}
					assertEquals("Date format testing", dateObj.getTaskDetails());
					assertEquals("2016-04-222016-08-30", output);
				}
			}
		}
	}

	@Test
	public void testFinDates1() {
		dateObj = new DateParser("She is getting married on 3 jun 2016   ");
		dateObj.findDates();
		String output = "";
		for (LocalDate date : dateObj.getDateList()) {
			output = output + date.toString();
		}
		assertEquals("She is getting married", dateObj.getTaskDetails());
		assertEquals("2016-06-03", output);
	}

	@Test
	public void testFinDates2() {
		dateObj = new DateParser("29feb16 read 100 books");
		dateObj.findDates();
		String output = "";
		for (LocalDate date : dateObj.getDateList()) {
			output = output + date.toString();
		}
		assertEquals("read 100 books", dateObj.getTaskDetails());
		assertEquals("2016-02-29", output);
	}

	@Test
	public void testFinDates3() {
		dateObj = new DateParser("3 AUG to 8 march");
		dateObj.findDates();
		String output = "";
		for (LocalDate date : dateObj.getDateList()) {
			output = output + date.toString();
		}
		assertEquals("", dateObj.getTaskDetails());
		assertEquals("2016-08-032017-03-08", output);
	}

	@Test
	public void testFinDates4() {
		String output = "";
		String testString = "Meet ABCD at 16:00 on 2-1-16 and 3-1-16 at the hotel ";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		for (LocalDate s : outList) {
			output = output + s.toString();
		}
		String expected = "2016-01-022016-01-03";
		assertEquals(expected, output.trim());
		assertEquals("Meet ABCD at 16:00 and at the hotel", dateObj.getTaskDetails());
	}

	@Test
	public void testFinDates5() {
		String output = "";
		String testString = "Meet ABCD at 16:00   at the hotel ";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		if (outList != null) {
			for (LocalDate s : outList) {
				output = output + s.toString();
			}
		}
		String expected = "";
		assertEquals(expected, output.trim());
		assertEquals("Meet ABCD at 16:00 at the hotel", dateObj.getTaskDetails());
	}

	@Test
	public void testFinDates6() {
		dateObj = new DateParser("She is getting married day after  tmr   ");
		dateObj.findDates();
		String output = "";
		for (LocalDate date : dateObj.getDateList()) {
			output = output + date.toString();
		}
		assertEquals("She is getting married", dateObj.getTaskDetails());
		assertEquals(LocalDate.now().plusDays(2).toString(), output);
	}

	@Test
	public void testFinDates7() {
		dateObj = new DateParser("She is getting married 7mar8mar ");
		dateObj.findDates();
		String output = "";
		if (dateObj.getDateList() != null) {
			for (LocalDate date : dateObj.getDateList()) {
				output = output + date.toString();
			}
		}
		assertEquals("She is getting married 7mar8mar", dateObj.getTaskDetails());
		assertEquals("", output);
	}

	@Test
	public void testFinDates8() {
		dateObj = new DateParser("See day aftr $tomorrow day aftr tomorrow.");
		dateObj.findDates();
		String output = "";
		if (dateObj.getDateList() != null) {
			for (LocalDate date : dateObj.getDateList()) {
				output = output + date.toString();
			}
		}
		assertEquals("See day aftr $tomorrow .", dateObj.getTaskDetails());
		assertEquals(LocalDate.now().plusDays(2).toString(), output);
	}

	@Test
	public void testFinDates9() {
		dateObj = new DateParser("work to be done frm day aftr tmw to 3 days  ");
		dateObj.findDates();
		String output = "";
		for (LocalDate date : dateObj.getDateList()) {
			output = output + date.toString();
		}
		assertEquals("work to be done", dateObj.getTaskDetails());
		assertEquals(LocalDate.now().plusDays(2).toString() + LocalDate.now().plusDays(3).toString(), output);
	}

	@Test
	public void testFinDates10() {
		dateObj = new DateParser("She is getting married in 3 days  ");
		dateObj.findDates();
		String output = "";
		for (LocalDate date : dateObj.getDateList()) {
			output = output + date.toString();
		}
		assertEquals("She is getting married", dateObj.getTaskDetails());
		assertEquals(LocalDate.now().plusDays(3).toString(), output);
	}

	@Test
	public void testFinDates11() {
		String output = "";
		String testString = "to 3march 8/3/19";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		if (outList != null) {
			for (LocalDate s : outList) {
				output = output + s.toString();
			}
		}
		String expected = "2017-03-032019-03-08";
		assertEquals(expected, output.trim());
		assertEquals("to", dateObj.getTaskDetails());
	}

	@Test
	public void testFinDates12() {
		String output = "";
		String testString = "3march 8/3/19 to";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		if (outList != null) {
			for (LocalDate s : outList) {
				output = output + s.toString();
			}
		}
		String expected = "2017-03-032019-03-08";
		assertEquals(expected, output.trim());
		assertEquals("to", dateObj.getTaskDetails());
	}

	@Test
	public void testFinDates13() {
		String output = "";
		String testString = "to 3march 8/3/19";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		if (outList != null) {
			for (LocalDate s : outList) {
				output = output + s.toString();
			}
		}
		String expected = "2017-03-032019-03-08";
		assertEquals(expected, output.trim());
		assertEquals("to", dateObj.getTaskDetails());
	}

	@Test
	public void testGetUpComingDayDate1() {
		String output = "";
		String testString = "Meet ABCD tomorrow at the hotel ";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		for (LocalDate s : outList) {
			output = output + s.toString();
		}
		String expected = LocalDate.now().plusDays(1).toString();
		assertEquals(expected, output.trim());
		assertEquals("Meet ABCD at the hotel", dateObj.getTaskDetails());
	}

	@Test
	public void testGetUpComingDayDate2() {
		String output = "";
		String testString = "Meet ABCD today and tomorrow at the hotel ";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		for (LocalDate s : outList) {
			output = output + s.toString();
		}
		String expected = LocalDate.now().toString() + LocalDate.now().plusDays(1).toString();
		assertEquals(expected, output.trim());
		assertEquals("Meet ABCD and at the hotel", dateObj.getTaskDetails());
	}

	@Test
	public void testGetDayOfWeekDate1() {
		String output = "";
		String testString = "Meet ABCD on wednesday at the hotel ";
		dateObj = new DateParser(testString);
		dateObj.findDates();
		ArrayList<LocalDate> outList = dateObj.getDateList();
		for (LocalDate s : outList) {
			output = output + s.toString();
		}
		String expected = "2016-04-13";
		assertEquals(expected, output.trim());
		assertEquals("Meet ABCD at the hotel", dateObj.getTaskDetails());
	}

	@Test
	public void testIsDayOfWeek1() {
		String testString = "wed";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.isDayOfWeek(testString));
	}

	@Test
	public void testIsDayOfWeek2() {
		String testString = "wednes";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.isDayOfWeek(testString));
	}

	@Test
	public void testIsDayOfWeek3() {
		String testString = "thuRs";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.isDayOfWeek(testString));
	}

	@Test
	public void testIsDayOfWeek4() {
		String testString = "th";
		dateObj = new DateParser(testString);
		assertEquals(false, dateObj.isDayOfWeek(testString));
	}

	@Test
	public void testIsDayOfWeek5() {
		String testString = "tues";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.isDayOfWeek(testString));
	}

	@Test
	public void testIsDayOfWeek6() {
		String testString = "SUNDAY";
		dateObj = new DateParser(testString);
		assertEquals(true, dateObj.isDayOfWeek(testString));
	}

	@Test
	public void checkGetUpComingDate() {
		String text = "day after tmw it is";
		dateObj = new DateParser(text);
		String word = dateObj.getUpComingDayWord(text);

		LocalDate date = dateObj.getUpcomingDayDate(word);
		assertEquals(LocalDate.now().plusDays(2), date);
	}

	@Test
	public void checkHasDayDuration() {
		dateObj = new DateParser();
		String text = "3days";
		assertEquals(true, dateObj.hasDayDuration(text));
	}

	@Test
	public void checkGetFirstXWords() {
		String text = "Hello it's me. I was wondering if after all these years";

		dateObj = new DateParser();
		assertEquals(null, dateObj.getFirstXWords(text, 0));
		assertEquals("Hello", dateObj.getFirstXWords(text, 1));
		assertEquals("Hello it's me.", dateObj.getFirstXWords(text, 3));
		assertEquals(null, dateObj.getFirstXWords(text, 18));
	}

}
```
###### \Parser\DateTimeParser.java
``` java

package Parser;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Collections;
//import java.util.Collections;

public class DateTimeParser {

	private static final int INVALID_SIZE = -1;
	private static final int FIRST_INDEX = 0;
	private static final int ONE_DAY = 1;

	private ArrayList<LocalDate> dateList;
	private ArrayList<LocalTime> timeList;

	/**************** CONSTRUCTORS *********************/
	// Default Constructor
	DateTimeParser() {
		this(null, null);
	}

	// Parameterized Constructor
	DateTimeParser(ArrayList<LocalDate> newDateList, ArrayList<LocalTime> newTimeList) {
		setDateList(newDateList);
		setTimeList(newTimeList);
	}

	/****************** SETTER METHODS ***********************/
	protected void setDateList(ArrayList<LocalDate> newDateList) {
		if (newDateList == null) {
			this.dateList = new ArrayList<LocalDate>();
		} else {
			this.dateList = newDateList;
		}
	}

	protected void setTimeList(ArrayList<LocalTime> newTimeList) {
		if (newTimeList == null) {
			this.timeList = new ArrayList<LocalTime>();
		} else {
			this.timeList = newTimeList;
		}
	}

	/******************* GETTER METHODS ***********************/
	public ArrayList<LocalDate> getDateList() {
		return this.dateList;
	}

	public ArrayList<LocalTime> getTimeList() {
		return this.timeList;
	}

	/**************** OTHER METHODS ***********************/
	public void arrangeDateTimeList() {
		ArrayList<LocalDateTime> alist;
		int aListSize = getDateTimeListSize(getDateList(), getTimeList());
		// System.out.println(aListSize);
		if (aListSize > INVALID_SIZE) {
			alist = createDateTimeList(aListSize);
			Collections.sort(alist);
			removeDuplicates(alist);
			separateDateAndTime(alist);
		}
	}

	/**
	 * This method makes sure that there are no duplicate copies of any date and
	 * time; so as to avoid unfavorable results.
	 */
	public void removeDuplicates(ArrayList<LocalDateTime> aList) {
		for (int index = 0; index < aList.size() - 1; index++) {
			if (aList.get(index).isEqual(aList.get(index + 1))) {
				aList.remove(index);
				index--;
			}
		}
	}

	void separateDateAndTime(ArrayList<LocalDateTime> alist) {
		ArrayList<LocalDate> newDateList = new ArrayList<LocalDate>();
		ArrayList<LocalTime> newTimeList = new ArrayList<LocalTime>();
		for (int index = FIRST_INDEX; index < alist.size(); index++) {
			newDateList.add(alist.get(index).toLocalDate());
			newTimeList.add(alist.get(index).toLocalTime());
		}
		setDateList(newDateList);
		setTimeList(newTimeList);
	}

	/**
	 * This method is invoked to ensure that both date and time lists are of
	 * equal sizes. If unequal, the empty spaces are filled up with appropriate
	 * values.
	 * 
	 * @param size
	 * @return a list of date and time combined.
	 */
	public ArrayList<LocalDateTime> createDateTimeList(int size) {
		ArrayList<LocalDateTime> alist = new ArrayList<LocalDateTime>();
		if (dateList.isEmpty()) {
			generateDateList(size);
		} else if (timeList.isEmpty()) {
			generateTimeList(size);
		} else if (dateList.size() > timeList.size()) {
			generateTimeList(size);
		} else if (dateList.size() < timeList.size()) {
			generateDateList(size);
		}
		for (int index = FIRST_INDEX; index < size; index++) {
			alist.add(LocalDateTime.of(dateList.get(index), timeList.get(index)));
		}
		return alist;
	}

	/**
	 * This method is invoked in the condition that there are more times than
	 * dates in the lists. As a result, the blank spaces in the date list are
	 * filled with either the same dates as the previous ones or the next day,
	 * as per the times provided.
	 * 
	 * @param size
	 *            is the size of the larger time list.
	 */
	public void generateDateList(int size) {
		for (int index = dateList.size(); index < size; index++) {
			LocalDate tempDate;
			LocalTime tempTime;
			if (index == FIRST_INDEX) {
				tempDate = LocalDate.now();
				tempTime = LocalTime.now();
			} else {
				tempDate = dateList.get(index - 1);
				tempTime = timeList.get(index - 1);
			}
			LocalDateTime tempDateTime = LocalDateTime.of(tempDate, timeList.get(index));
			if (tempDateTime.isBefore(LocalDateTime.of(tempDate, tempTime))) {
				tempDate = tempDate.plusDays(ONE_DAY);
			}
			dateList.add(tempDate);
		}
	}

	/**
	 * This method is invoked in the condition that there are more dates than
	 * times in the lists. As a result, the blank spaces in the time list are
	 * filled with MAX time.
	 * 
	 * @param size
	 *            is the size of the larger date list.
	 */
	public void generateTimeList(int size) {
		for (int index = timeList.size(); index < size; index++) {
			timeList.add(LocalTime.MAX);
		}
	}

	/**
	 * This method is used to determine the final size of the date and time
	 * lists.
	 * 
	 * @param dateList
	 * @param timeList
	 * @return the greater of the dateList and timeList size if valid; otherwise
	 *         -1.
	 */
	public int getDateTimeListSize(ArrayList<LocalDate> dateList, ArrayList<LocalTime> timeList) {
		if (dateList == null || timeList == null) {
			return INVALID_SIZE;
		}
		return (dateList.size() > timeList.size()) ? dateList.size() : timeList.size();
	}
}
```
###### \Parser\DateTimeParserTest.java
``` java

package Parser;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;

public class DateTimeParserTest {

	@Test
	public void testGetDateList1(){
		String d = "", t ="";
		ArrayList<LocalDate> dates = addDates1();
		ArrayList<LocalTime> times = addTimes1();
		DateTimeParser obj = new DateTimeParser(dates,times);
		obj.arrangeDateTimeList();
		for(LocalDate date : obj.getDateList()) {
			d = d + date.toString();
		}
		for(LocalTime time : obj.getTimeList()) {
			t = t + time.toString();
		}
		assertEquals("2007-03-132007-03-232008-03-13",d);
		assertEquals("10:3000:3020:30",t);
	}
	
	public ArrayList<LocalDate> addDates1(){
		ArrayList<LocalDate> dates = new ArrayList<LocalDate>();
		dates.add(LocalDate.parse("2007-03-13"));
		dates.add(LocalDate.parse("2007-03-23"));
		dates.add(LocalDate.parse("2008-03-13"));
		return dates;
	}
	
	public ArrayList<LocalTime> addTimes1(){
		ArrayList<LocalTime> times = new ArrayList<LocalTime>();
		times.add(LocalTime.parse("10:30"));
		times.add(LocalTime.parse("00:30"));
		times.add(LocalTime.parse("20:30"));
		return times;
	}
	

	@Test
	public void testGetDateList2(){
		String d = "", t ="";
		ArrayList<LocalDate> dates = addDates2();
		ArrayList<LocalTime> times = addTimes2();
		DateTimeParser obj = new DateTimeParser(dates,times);
		obj.arrangeDateTimeList();
		for(LocalDate date : obj.getDateList()) {
			d = d + date.toString();
		}
		for(LocalTime time : obj.getTimeList()) {
			t = t + time.toString();
		}
		assertEquals("2007-03-132008-03-132008-03-13",d);
		assertEquals("10:3000:3020:30",t);
	}
	
	public ArrayList<LocalDate> addDates2(){
		ArrayList<LocalDate> dates = new ArrayList<LocalDate>();
		dates.add(LocalDate.parse("2007-03-13"));
		dates.add(LocalDate.parse("2008-03-13"));
		return dates;
	}
	
	public ArrayList<LocalTime> addTimes2(){
		ArrayList<LocalTime> times = new ArrayList<LocalTime>();
		times.add(LocalTime.parse("10:30"));
		times.add(LocalTime.parse("00:30"));
		times.add(LocalTime.parse("20:30"));
		return times;
	}
	
	@Test
	public void testGetDateList3(){
		String d = "", t ="";
		ArrayList<LocalDate> dates = addDates3();
		ArrayList<LocalTime> times = addTimes3();
		DateTimeParser obj = new DateTimeParser(dates,times);
		obj.arrangeDateTimeList();
		for(LocalDate date : obj.getDateList()) {
			d = d + date.toString();
		}
		for(LocalTime time : obj.getTimeList()) {
			t = t + time.toString();
		}
		assertEquals("2007-03-132008-03-132008-03-14",d);
		assertEquals("10:3020:3000:30",t);
	}
	
	public ArrayList<LocalDate> addDates3(){
		ArrayList<LocalDate> dates = new ArrayList<LocalDate>();
		dates.add(LocalDate.parse("2007-03-13"));
		dates.add(LocalDate.parse("2008-03-13"));
		return dates;
	}
	
	public ArrayList<LocalTime> addTimes3(){
		ArrayList<LocalTime> times = new ArrayList<LocalTime>();
		times.add(LocalTime.parse("10:30"));
		times.add(LocalTime.parse("20:30"));
		times.add(LocalTime.parse("00:30"));
		return times;
	}
}
```
###### \Parser\IndexParser.java
``` java

package Parser;

import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

/**
 * IndexParser is used to parse the given String taskDetails and retrieve all
 * the indexes contained in it.
 * 
 * Indexes are specified only after delete, done, undone and edit commands.
 * 
 * In addition, edit allows for only one index number, whereas done, undone and
 * delete support multiple indexes.
 * 
 * Multiple indexes can be separated by either a comma, or a whitespace. A range
 * of digits, separated by a hyphen to keyword "to" can also be used.
 */
public class IndexParser {

	// Instance Variables
	private String taskDetails;
	private Command command;
	private ArrayList<Integer> indexList;

	/**************** CONSTRUCTORS *********************/
	// Default Constructor
	IndexParser() {
		this(null, ParserConstants.STRING_EMPTY);
	}

	// Parameterized Constructor
	IndexParser(Command newCommandDetails, String newTaskDetails) {
		this(newCommandDetails, newTaskDetails, new ArrayList<Integer>());
	}

	IndexParser(Command newCommandDetails, String newTaskDetails, ArrayList<Integer> newIndexList) {
		setTaskDetails(newTaskDetails);
		setCommandDetails(newCommandDetails);
		setIndexList(newIndexList);
	}

	/****************** SETTER METHODS ***********************/
	protected void setTaskDetails(String newTaskDetails) {
		if (newTaskDetails == null || newTaskDetails.isEmpty()) {
			this.taskDetails = ParserConstants.STRING_EMPTY;
		} else {
			newTaskDetails = cleanupExtraWhitespace(newTaskDetails);
			this.taskDetails = newTaskDetails;
		}
	}

	public void setCommandDetails(Command newCommandDetails) {
		this.command = newCommandDetails;
	}

	public void setIndexList(ArrayList<Integer> newIndexList) {
		this.indexList = newIndexList;
	}

	/******************* GETTER METHODS ***********************/
	public String getTaskDetails() {
		return this.taskDetails;
	}

	public Command getCommand() {
		return this.command;
	}

	public ArrayList<Integer> getIndexList() {
		if (indexList.isEmpty()) {
			return null;
		}
		return this.indexList;
	}

	/**************** OTHER METHODS ***********************/

	public void findIndexList() throws Exception {
		Command.COMMAND_TYPE commandType = command.getCommandType();
		switch (commandType) {
		case DELETE_TASK:
			detectMultipleIndexes();
			removeDuplicates();
			break;
		case COMPLETE_TASK:
			detectMultipleIndexes();
			removeDuplicates();
			break;
		case INCOMPLETE_TASK:
			detectMultipleIndexes();
			removeDuplicates();
			break;
		case MODIFY_TASK:
			detectSingleIndex();
			break;
		default:
			// return
			break;
		}
	}

	/**
	 * Delete, Done and Undone support multiple indexes. This method helps parse
	 * the given input String and generate the index list.
	 * 
	 * @throws Exception
	 */
	public void detectMultipleIndexes() throws Exception {
		if (taskDetails == null || taskDetails.isEmpty()) {
			return;
		}
		String taskStatement = formatDelimiters(getTaskDetails());
		String[] tempIndexArray = taskStatement.split(ParserConstants.REGEX_INDEX_DELIMITER);
		// ArrayList<String> tempIndexList = convertArrayToList(tempIndexArray);
		generateIndexList(tempIndexArray);
		sortIndexList();
	}

	/**
	 * The Edit command provided by the user can contain only a single index
	 * number. This method is used to retrieve that single index, which should
	 * be at the start of the String taskDetails.
	 */
	public void detectSingleIndex() {
		Pattern indexPattern = Pattern.compile(ParserConstants.REGEX_DIGITS_AT_START);
		Matcher indexMatcher = indexPattern.matcher(taskDetails);
		if (indexMatcher.find()) {
			int startIndex = indexMatcher.start();
			int endIndex = indexMatcher.end();
			addIndexToList(taskDetails.substring(startIndex, endIndex).trim());
			removeIndexAtStartFromTaskDetails();
		}
	}

	public ArrayList<String> convertArrayToList(String[] tempArray) throws Exception {
		return new ArrayList<String>(Arrays.asList(tempArray));
	}

	private void generateIndexList(String[] tempList) throws Exception {
		for (String item : tempList) {
			item = cleanupExtraWhitespace(item);
			if (containsIndexRange(item)) {
				addRangeToIndexList(item);
			} else if (isOnlyDigits(item)) {
				addIndexToList(item);
			} else {
				throw new Exception("Invalid Index List");
			}
		}
	}

	public void sortIndexList() {
		Collections.sort(indexList);
	}

	/**
	 * This method helps in generating the entire array of indexes out of the
	 * indexes specified as a range.
	 * 
	 * @param item
	 * @throws Exception
	 */
	private void addRangeToIndexList(String item) throws Exception {
		String[] range = new String[2];
		if (item.contains(ParserConstants.STRING_HYPHEN)) {
			range = item.split(ParserConstants.STRING_HYPHEN);
		} else if (item.contains(ParserConstants.STRING_TO)) {
			range = item.split(ParserConstants.STRING_TO);
		}

		if (range.length != 2) {
			throw new Exception("Invalid Index List");
		}

		for (int index = ParserConstants.FIRST_INDEX; index < range.length; index++) {
			range[index] = cleanupExtraWhitespace(range[index]);
		}

		for (int index = Integer.parseInt(range[ParserConstants.FIRST_INDEX]); index <= Integer
				.parseInt(range[range.length - 1]); index++) {
			indexList.add(index);
		}
	}

	private boolean isOnlyDigits(String item) {
		item = cleanupExtraWhitespace(item);
		return item.matches(ParserConstants.REGEX_ONLY_DIGITS);
	}

	private void addIndexToList(String item) {
		indexList.add(Integer.parseInt(item));
	}

	public void removeIndexAtStartFromTaskDetails() {
		String taskStatement = getTaskDetails();
		taskStatement = taskStatement.replaceFirst(ParserConstants.REGEX_DIGITS_AT_START,
				ParserConstants.STRING_WHITESPACE);
		taskStatement = CommandParser.cleanupExtraWhitespace(taskStatement);
		setTaskDetails(taskStatement);
	}

	/**
	 * This method makes sure that there are no duplicate copies of any index;
	 * so as to avoid unfavorable results.
	 */
	public void removeDuplicates() {
		for (int index = 0; index < indexList.size() - 1; index++) {
			if (indexList.get(index) == indexList.get(index + 1)) {
				indexList.remove(index);
				index--;
			}
		}
	}

	/**
	 * A specific string contains an index range only if contains the "to"
	 * keyword or a hyphen. This method is used to check if item contains an
	 * index range or not.
	 * 
	 * @param item
	 * @return true, if item contains an index range; false otherwise.
	 */
	public boolean containsIndexRange(String item) {
		item = item.toLowerCase();
		return item.contains(ParserConstants.STRING_HYPHEN) || item.contains(ParserConstants.STRING_TO);
	}

	/**
	 * This method is used to format the delimiters used to parse indexes. It
	 * replaces all the whitespace and comma combinations to a single comma
	 * without a whitespace and all range delimiters to a hyphen.
	 * 
	 * @param textToFormat
	 * @return textToFormat; after it has been correctly formatted.
	 */
	public String formatDelimiters(String textToFormat) {
		textToFormat = textToFormat.toLowerCase();
		textToFormat = textToFormat.replaceAll(ParserConstants.REGEX_COMMA_WITH_SPACES, ParserConstants.STRING_COMMA)
				.replaceAll(ParserConstants.REGEX_RANGE_DELIMITER, ParserConstants.STRING_HYPHEN);
		return textToFormat;
	}

	/**
	 * This method removes the unnecessary white spaces present in the string.
	 * 
	 * @param someText
	 *            is any string with several white spaces.
	 * @return someText excluding the extra unnecessary white spaces.
	 */
	private static String cleanupExtraWhitespace(String someText) {
		Pattern extraSpace = Pattern.compile(ParserConstants.REGEX_EXTRA_WHITESPACE);
		Matcher regexMatcher = extraSpace.matcher(someText.trim());
		String cleanText = regexMatcher.replaceAll(ParserConstants.STRING_WHITESPACE);
		return cleanText;
	}
}
```
###### \Parser\IndexParserTest.java
``` java

package Parser;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class IndexParserTest {

	IndexParser indexObj;

	@Test
	public void testFindIndex1() throws Exception {
		Command cmd = new Command("del", null);
		String testString = "1, 3 , 5";
		String output = "";
		indexObj = new IndexParser(cmd, testString);
		indexObj.findIndexList();
		for (int x : indexObj.getIndexList()) {
			output += x;
		}
		assertEquals("135", output);
	}

	@Test
	public void testFindIndex2() throws Exception {
		Command cmd = new Command("d", null);
		String testString = "1, 3 TO 5";
		String output = "";
		indexObj = new IndexParser(cmd, testString);
		indexObj.findIndexList();
		for (int x : indexObj.getIndexList()) {
			output += x;
		}
		assertEquals("1345", output);
	}

	@Test
	public void testFindIndex3() throws Exception {
		Command cmd = new Command("done", null);
		String testString = "1, 3 , 5";
		String output = "";
		indexObj = new IndexParser(cmd, testString);
		indexObj.findIndexList();
		for (int x : indexObj.getIndexList()) {
			output += x;
		}
		assertEquals("135", output);
	}

	@Test
	public void testFindIndex4() throws Exception {
		Command cmd = new Command("del", null);
		String testString = "2, 1-3";
		String output = "";
		indexObj = new IndexParser(cmd, testString);
		indexObj.findIndexList();
		for (int x : indexObj.getIndexList()) {
			output += x;
		}
		assertEquals("123", output);
	}

	@Test
	public void testFindIndex5() throws Exception {
		Command cmd = new Command("e", null);
		String testString = "60 23 sep 16";
		String output = "";
		indexObj = new IndexParser(cmd, testString);
		indexObj.findIndexList();
		for (int x : indexObj.getIndexList()) {
			output += x;
		}
		assertEquals("60", output);
		assertEquals("23 sep 16", indexObj.getTaskDetails());
	}

	@Test
	public void testFindIndex6(){
		boolean isException = true;
		try {
			Command cmd = new Command("delete", null);
			String testString = "error";
			indexObj = new IndexParser(cmd, testString);
			indexObj.findIndexList();
			isException = false;
		} catch (Exception e) {
			assertEquals(true, isException);
		}
		assertEquals(true, isException);
	}
}
```
###### \Parser\ParserConstants.java
``` java

package Parser;

public class ParserConstants {

	// Command Class, primarily
	static final String[] COMMAND_ADD = { "add", "+", "a" };
	static final String[] COMMAND_DELETE = { "delete", "d", "del", "-", "remove", "rm" };
	static final String[] COMMAND_MODIFY = { "edit", "update", "e" };
	static final String[] COMMAND_COMPLETE = { "done", "completed", "archive" };
	static final String[] COMMAND_INCOMPLETE = { "undone" };
	static final String[] COMMAND_VIEW = { "view", "v", "show", "display" };
	static final String[] COMMAND_SEARCH = { "search", "find" };
	static final String[] COMMAND_EXIT = { "exit", "quit", "q" };
	static final String[] COMMAND_UNDO = { "undo", "z" };
	static final String[] COMMAND_REDO = { "redo", "y" };
	static final String[] COMMAND_SET_DIRECTORY = { "set" };
	static final String[] COMMAND_HOME = { "home" };
	static final String[] COMMAND_HELP = { "help" };
	static final String COMMAND_INVALID = null;
	static final String COMMAND_EMPTY = "";

	// Parameters of Task object
	static final String[] PARAMETER_DESCRIPTION = { "description", "detail", "details", "desc" };
	static final String[] PARAMETER_DATE = { "date", "dates" };
	static final String[] PARAMETER_TIME = { "time", "times" };

	// Regular Expressions
	static final String REGEX_EXTRA_WHITESPACE = "\\s{2,}";
	static final String REGEX_POSSIBLE_DATE = "(^|\\s)(\\w|-)";
	static final String REGEX_POSSIBLE_DURATION = "^\\d+[A-Za-z]{2,}";
	static final String REGEX_POSSIBLE_TIME = "(^|\\s)\\d";
	// static final String REGEX_POSSIBLE_TIME = "(^|\\s|\\G)\\d";
	static final String REGEX_DIGITS_VALID_END = "(\\s|^|,|-|\\G)\\d+(\\s|$|,|-)";
	static final String REGEX_VALID_START = "(^|\\s)";
	static final String REGEX_DIGITS_AT_START = "^\\d+\\s";
	static final String REGEX_INDEX_DELIMITER = "(,|\\s)";
	static final String REGEX_RANGE_DELIMITER = "\\s*((to)|-)\\s*";
	static final String REGEX_ONLY_DIGITS = "\\b\\d+\\b";
	static final String REGEX_ONLY_WORDS = "\\b\\w+\\b";
	static final String REGEX_COMMA_WITH_SPACES = "\\s*,\\s*";
	static final String REGEX_HYPHEN_WITH_DIGITS = "\\d+-\\d+";
	static final String REGEX_POSSIBLE_DIRECTORY = "([A-Za-z]:\\\\\\\\\\w+)";

	// Position/Index based integer constants
	static final int NO_WHITE_SPACE = -1;
	static final int DEFAULT_INDEX_NUMBER = -1;
	static final int FIRST_INDEX = 0;
	static final int INVALID_SIZE = -1;
	static final int ONE_WORD = 1;
	static final int TWO_WORDS = 2;
	static final int THREE_WORDS = 3;

	// Date related constants
	static final int CENTURY = 100;
	static final int ONE_YEAR = 1;
	static final int FIRST_DAY_OF_MONTH = 1;
	static final int INDEX_DAY_OF_MONTH = 0;
	static final int INDEX_MONTH = 1;
	static final int INDEX_YEAR = 2;
	static final int DAYS_IN_WEEK = 7;
	// Acceptable date formats
	static final String DATE_FORMAT_HASH_DAY_MONTH_NUM_YEAR_LONG = "d/M/uuuu";
	static final String DATE_FORMAT_HASH_DAY_MONTH_NUM_YEAR_SHORT = "d/M/uu";
	static final String DATE_FORMAT_HASH_DAY_MONTH_NUM = "d/M";
	static final String DATE_FORMAT_HYPHEN_DAY_MONTH_NUM = "d-M";
	static final String DATE_FORMAT_HYPHEN_DAY_MONTH_NUM_YEAR_LONG = "d-M-uuuu";
	static final String DATE_FORMAT_HYPHEN_DAY_MONTH_NUM_YEAR_SHORT = "d-M-uu";
	static final String DATE_FORMAT_DAY_MONTH_LONG_YEAR_LONG_NOSPACE = "dMMMMuuuu";
	static final String DATE_FORMAT_DAY_MONTH_LONG_YEAR_SHORT_NOSPACE = "dMMMMuu";
	static final String DATE_FORMAT_DAY_MONTH_SHORT_YEAR_LONG_NOSPACE = "dMMMuuuu";
	static final String DATE_FORMAT_DAY_MONTH_SHORT_YEAR_SHORT_NOSPACE = "dMMMuu";
	static final String DATE_FORMAT_DAY_MONTH_LONG_SPACE_YEAR_LONG = "dMMMM uuuu";
	static final String DATE_FORMAT_DAY_MONTH_LONG_SPACE_YEAR_SHORT = "dMMMM uu";
	static final String DATE_FORMAT_DAY_MONTH_SHORT_SPACE_YEAR_LONG = "dMMM uuuu";
	static final String DATE_FORMAT_DAY_MONTH_SHORT_SPACE_YEAR_SHORT = "dMMM uu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_LONG_YEAR_LONG = "d MMMMuuuu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_LONG_YEAR_SHORT = "d MMMMuu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_SHORT_YEAR_LONG = "d MMMuuuu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_SHORT_YEAR_SHORT = "d MMMuu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_LONG_SPACE_YEAR_LONG = "d MMMM uuuu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_LONG_SPACE_YEAR_SHORT = "d MMMM uu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_SHORT_SPACE_YEAR_LONG = "d MMM uuuu";
	static final String DATE_FORMAT_DAY_SPACE_MONTH_SHORT_SPACE_YEAR_SHORT = "d MMM uu";

	static final String DATE_FORMAT_MONTH_LONG_DAY_SPACE_YEAR_LONG = "MMMMd uuuu";
	static final String DATE_FORMAT_MONTH_LONG_SPACE_DAY_YEAR_LONG = "MMMM d uuuu";
	static final String DATE_FORMAT_MONTH_SHORT_DAY_SPACE_YEAR_LONG = "MMMd uuuu";
	static final String DATE_FORMAT_MONTH_SHORT_SPACE_DAY_SPACE_YEAR_LONG = "MMM d uuuu";

	static final String DATE_FORMAT_DAY_MONTH_LONG_NOSPACE = "dMMMM";
	static final String DATE_FORMAT_DAY_MONTH_SHORT_NOSPACE = "dMMM";
	static final String DATE_FORMAT_DAY_MONTH_SHORT = "d MMM";
	static final String DATE_FORMAT_DAY_MONTH_LONG = "d MMMM";
	static final String DATE_FORMAT_MONTH_LONG_DAY_NOSPACE = "MMMMd";
	static final String DATE_FORMAT_MONTH_LONG_DAY = "MMMM d";
	static final String DATE_FORMAT_MONTH_SHORT_DAY_NOSPACE = "MMMd";
	static final String DATE_FORMAT_MONTH_SHORT_DAY = "MMM d";

	static final String[] DAY_DURATION = { "day", "days", "week", "weeks", "month", "months", "year", "years", "yr",
			"yrs" };
	static final int LAST_INDEX_OF_DAY = 1;
	static final int LAST_INDEX_OF_WEEK = 3;
	static final int LAST_INDEX_OF_MONTH = 5;
	static final int LAST_INDEX_OF_YEAR = 9;
	static final String[] DATE_KEYWORD = { "by", "on", "in", "before", "from", "frm" };

	static final String[] UPCOMING_DAYS = { "today", "tdy", "tomorrow", "tmr", "tmw", "tmrw", "overmorrow",
			"day after tomorrow", "day after tmr", "day after tmw", "day after tmrw", "day aftr tomorrow",
			"day aftr tmr", "day aftr tmw", "day aftr tmrw" };
	static final String[] UPCOMING_PERIOD_KEYWORD = { "this", "next", /* "next to next" */ };
	// Days of the week
	static final String[] DAYS_OF_WEEK_SHORT = { "", "mon", "tue", "wed", "thu", "fri", "sat", "sun" };
	static final String[] DAYS_OF_WEEK_MEDIUM = { "", "", "tues", "wednes", "thurs", "", "", "" };
	static final String[] DAYS_OF_WEEK_LONG = { "", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday",
			"sunday" };

	static final int MIN_SIZE = 1;

	// Time related constants
	static final int MAX_MINUTES = 59;
	static final int MAX_HOUR = 23;
	static final int TWELVE_HOURS = 12;
	// Acceptable Time formats
	static final String TIME_FORMAT_12HOUR_MIN_AMPM_WITHOUT_SPACE = "hmma";
	static final String TIME_FORMAT_12HOUR_MIN_AMPM_WITH_SPACE = "hmm a";
	static final String TIME_FORMAT_12HOUR_MIN_AMPM_WITH_PERIOD_WITHOUT_SPACE = "h.mma";
	static final String TIME_FORMAT_12HOUR_MIN_AMPM_WITH_PERIOD_WITH_SPACE = "h.mm a";
	static final String TIME_FORMAT_12HOUR_MIN_AMPM_WITH_COLOM_WITHOUT_SPACE = "h:mma";
	static final String TIME_FORMAT_12HOUR_MIN_AMPM_WITH_COLON_WITH_SPACE = "h:mm a";
	static final String TIME_FORMAT_12HOUR_AMPM_WITHOUT_SPACE = "ha";
	static final String TIME_FORMAT_12HOUR_AMPM_WITH_SPACE = "h a";
	static final String TIME_FORMAT_24HOUR_COLON = "H:mm";
	static final String TIME_FORMAT_24HOUR_PERIOD = "H.mm";
	static final String TIME_FORMAT_24HOUR_MIN = "HHmm";

	static final String[] TIME_DURATION = { "mins", "min", "minutes", "minute", "hr", "hrs", "hours", "hour" };
	static final int LAST_INDEX_OF_MIN = 3;
	static final int LAST_INDEX_OF_HOUR = 7;
	static final String[] TIME_KEYWORD = { "by", "at", "in", "before", "from", "frm" };

	static final char WHITE_SPACE = ' ';

	static final String STRING_EMPTY = "";
	static final String STRING_WHITESPACE = " ";
	static final String STRING_COMMA = ",";
	static final String STRING_HYPHEN = "-";
	static final String STRING_HYPHEN_WHITESPACE = " - ";
	static final String STRING_TO = "to";
	static final String STRING_OVERDUE = "overdue";

	// Number in words
	static final String[] NUM_TO_WORDS = { "", "one", "two", "three", "four", "five" };

	// Months
	static final String[] MONTHS_SHORT = { "", "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct",
			"nov", "dec" };
	static final String[] MONTHS_LONG = { "", "january", "february", "march", "april", "may", "june", "july", "august",
			"september", "october", "november", "december" };

	static final String[] VALID_END = { ",", " ", ".", "" };

}
```
###### \Parser\ParserTestSuite.java
``` java

package Parser;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
@RunWith(Suite.class)
@Suite.SuiteClasses({
  CommandParserTest.class,
  DateParserTest.class,
  TimeParserTest.class,
  IndexParserTest.class,
  DateTimeParserTest.class
  
})
public class ParserTestSuite {   
}  		
```
###### \Parser\TimeParser.java
``` java

package Parser;

import java.util.ArrayList;
import java.util.Locale;
import java.text.ParsePosition;
import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import Parser.ParserConstants;

/*
 * This class contains all possible combinations of time, that the user can
 * input as command into Schedule Hacks.
 */
public class TimeParser {

	// Instance Variables
	private String taskDetails;
	private ArrayList<LocalTime> timeList;
	private ArrayList<LocalDate> dateList;

	private boolean hasRangeKeyword = false;
	private int rangeKeywordStartPos = -1;
	private int rangeKeywordEndPos = -1;

	/**************** CONSTRUCTORS *********************/
	// Default Constructor
	TimeParser() {
		this(ParserConstants.STRING_EMPTY, new ArrayList<LocalTime>(), new ArrayList<LocalDate>());
	}

	// Parameterized Constructor
	TimeParser(String newTaskDetails) {
		this(newTaskDetails, new ArrayList<LocalTime>(), new ArrayList<LocalDate>());
	}

	TimeParser(String newTaskDetails, ArrayList<LocalDate> newDateList) {
		this(newTaskDetails, new ArrayList<LocalTime>(), newDateList);
	}

	TimeParser(String newTaskDetails, ArrayList<LocalTime> newTimeList, ArrayList<LocalDate> newDateList) {
		setTaskDetails(newTaskDetails);
		setTimeList(newTimeList);
		setDateList(newDateList);
	}

	/****************** SETTER METHODS ***********************/
	protected void setTaskDetails(String newTaskDetails) {
		this.taskDetails = cleanupExtraWhitespace(newTaskDetails);
	}

	protected void setTimeList(ArrayList<LocalTime> timeList) {
		this.timeList = timeList;
	}

	protected void setDateList(ArrayList<LocalDate> dateList) {
		this.dateList = dateList;
	}

	/******************* GETTER METHODS ***********************/
	public String getTaskDetails() {
		return cleanupExtraWhitespace(this.taskDetails);
	}

	public ArrayList<LocalTime> getTimeList() {
		if (timeList == null || timeList.isEmpty()) {
			return null;
		}
		return this.timeList;
	}

	public ArrayList<LocalDate> getDateList() {
		if (dateList.isEmpty()) {
			return null;
		}
		return this.dateList;
	}

	/**************** OTHER METHODS ***********************/

	/**
	 * This method is used to extract all the times from taskDetails
	 */
	public void findTimes() {
		formatHyphenDelimiter();
		String taskDetails = getTaskDetails();

		Pattern timePattern = Pattern.compile(ParserConstants.REGEX_POSSIBLE_TIME);
		Matcher timeMatcher = timePattern.matcher(taskDetails);
		while (timeMatcher.find()) {
			try {
				String previousWord = getLastWordInRange(taskDetails, timeMatcher.start());
				String tempString = cleanupExtraWhitespace(taskDetails.substring(timeMatcher.start()));

				if (addToListIfValidTime(tempString, previousWord, timeMatcher.start())) {
				} else {
					if (hasTimeDuration(tempString)) {
						String timeDuration = getTimeDurationWord(tempString);
						if (taskDetailsContains(timeDuration)) {
							addValidTimeToList(getParsedTimeDuration(timeDuration));
							if (isValidKeyWord(previousWord)
									|| isValidRangeKeyWord(previousWord, timeMatcher.start(), null)) {
								removeTimeFromTaskDetails(
										previousWord + ParserConstants.STRING_WHITESPACE + timeDuration);
							} else {
								removeTimeFromTaskDetails(timeDuration);
							}
						}
					}
				}
			} catch (Exception e) {
				// do nothing
			}
		}
		arrangeTimeList();
	}

	/**
	 * This method checks if the immediate String contains a time. If it is a
	 * Valid Time, it adds it to the timeList.
	 * 
	 * @param statement
	 * @param keyword
	 * @return true, if the immediate String is a valid time; otherwise false.
	 */
	public boolean addToListIfValidTime(String statement, String keyword, int timeStartPos) {
		String end = ParserConstants.STRING_EMPTY;
		for (DateTimeFormatter format : generateTimeFormatList()) {
			DateTimeFormatter myFormatter = new DateTimeFormatterBuilder().parseCaseInsensitive().append(format)
					.toFormatter(Locale.ENGLISH);
			try {
				ParsePosition index = new ParsePosition(ParserConstants.FIRST_INDEX);
				LocalTime parsedTime = LocalTime.from(myFormatter.parse(statement.trim(), index));

				if (index.getIndex() < statement.length()) {
					end = statement.substring(index.getIndex());
				}
				statement = statement.substring(ParserConstants.FIRST_INDEX, index.getIndex());

				if (taskDetailsContains(statement) && isValidEnd(end)) {
					addValidTimeToList(parsedTime);
					if (isValidKeyWord(keyword) || isValidRangeKeyWord(keyword, timeStartPos, parsedTime)) {
						removeTimeFromTaskDetails(keyword + ParserConstants.STRING_WHITESPACE + statement);
					} else {
						removeTimeFromTaskDetails(statement);
					}
					return true;
				}
			} catch (IndexOutOfBoundsException e) {
				// do nothing
			} catch (DateTimeParseException e) {
				// do nothing
			} catch (DateTimeException e) {
				// do nothing
			}
		}
		return false;
	}

	/**
	 * This method removes the particular textToRemove from taskDetails.
	 * 
	 * @param textToRemove
	 */
	public void removeTimeFromTaskDetails(String textToRemove) {

		if (taskDetails.startsWith(textToRemove)) {
			taskDetails = CommandParser
					.cleanupExtraWhitespace(taskDetails.replaceFirst(textToRemove, ParserConstants.STRING_WHITESPACE));
		} else {
			taskDetails = CommandParser
					.cleanupExtraWhitespace(taskDetails.replaceFirst(textToRemove, ParserConstants.STRING_WHITESPACE));
		}
	}

	public LocalTime getParsedTimeDuration(String text) {
		try {
			String firstWord = ParserConstants.STRING_EMPTY;
			String secondWord = ParserConstants.STRING_EMPTY;
			if (isFirstWordTimeDuration(text)) {
				int splitPos = -1;
				for (int index = ParserConstants.FIRST_INDEX; index < text.length(); index++) {
					if (!Character.isDigit(text.charAt(index))) {
						splitPos = index;
						break;
					}
				}
				secondWord = text.substring(splitPos);
				firstWord = text.substring(ParserConstants.FIRST_INDEX, splitPos);
			} else {
				firstWord = getFirstXWords(text, ParserConstants.ONE_WORD);
				secondWord = text.replace(firstWord, ParserConstants.STRING_WHITESPACE).trim();
			}
			LocalTime parsedTime = getTimeDuration(firstWord, secondWord);
			return parsedTime;
		} catch (Exception e) {
			// no exception encountered, just a precaution
		}
		return null;
	}

	/**
	 * This method extracts the time duration word from the given textToSearch.
	 * 
	 * @param textToSearch
	 * @return time duration word from textToSearch.
	 */
	public String getTimeDurationWord(String textToSearch) {
		String firstWord = getStartString(getFirstXWords(textToSearch, ParserConstants.ONE_WORD));

		if (isFirstWordTimeDuration(textToSearch)) {
			return firstWord;
		} else {
			return getStartString(getFirstXWords(textToSearch, ParserConstants.TWO_WORDS));
		}
	}

	public LocalTime getTimeDuration(String firstWord, String secondWord) {
		LocalTime parsedTime = getTimeNow();
		int unitsToAdd = Integer.parseInt(firstWord);
		int indexOfKeyword = indexOf(secondWord, ParserConstants.TIME_DURATION);
		if (indexOfKeyword <= ParserConstants.LAST_INDEX_OF_MIN) {
			parsedTime = parsedTime.plusMinutes(unitsToAdd);
		} else {
			parsedTime = parsedTime.plusHours(unitsToAdd);
		}
		return parsedTime;
	}

	/**
	 * Time duration refers to a number followed by either hours or minutes. The
	 * digit and the String may or may not have a whitespace in between.
	 * 
	 * @param tempString
	 * @return true if tempString starts with a time duration word; false
	 *         otherwise.
	 */
	public boolean hasTimeDuration(String tempString) {
		try {
			return isFirstWordTimeDuration(tempString) || isFirstTwoWordsTimeDuration(tempString);
		} catch (NullPointerException e) {
			// do nothing
		} catch (NumberFormatException e) {
			// do nothing
		} catch (IndexOutOfBoundsException e) {
			// do nothing
		}
		return false;
	}

	/**
	 * This method is used to check the first word of inputString for occurrence
	 * of time duration.
	 * 
	 * @param inputString
	 * @return
	 * @throws NullPointerException
	 * @throws NumberFormatException
	 * @throws IndexOutOfBoundsException
	 */
	public boolean isFirstWordTimeDuration(String inputString)
			throws NullPointerException, NumberFormatException, IndexOutOfBoundsException {
		String firstWord = getFirstXWords(inputString, ParserConstants.ONE_WORD);
		String endString = getEnd(firstWord);
		firstWord = getStartString(firstWord);

		if (firstWord.matches(ParserConstants.REGEX_POSSIBLE_DURATION)) {
			int splitPos = -1;
			for (int index = ParserConstants.FIRST_INDEX; index < firstWord.length(); index++) {
				if (!Character.isDigit(firstWord.charAt(index))) {
					splitPos = index;
					break;
				}
			}
			String secondWord = firstWord.substring(splitPos);
			firstWord = firstWord.substring(ParserConstants.FIRST_INDEX, splitPos);
			if (hasInDictionary(ParserConstants.TIME_DURATION, secondWord) && isValidEnd(endString)) {
				Integer.parseInt(firstWord);
				return true;
			}
		}
		return false;
	}

	/**
	 * This method is used to check the first two words of inputString for
	 * occurrence of time duration.
	 * 
	 * @param inputString
	 * @return
	 * @throws NullPointerException
	 * @throws NumberFormatException
	 */
	public boolean isFirstTwoWordsTimeDuration(String inputString) throws NullPointerException, NumberFormatException {
		String firstWord = getFirstXWords(inputString, ParserConstants.ONE_WORD);
		String first2Words = getFirstXWords(inputString, ParserConstants.TWO_WORDS);
		String secondWord = first2Words.replace(firstWord, ParserConstants.STRING_WHITESPACE).trim();
		String endString = getEnd(secondWord);

		if (hasInDictionary(ParserConstants.TIME_DURATION, getStartString(secondWord)) && isValidEnd(endString)) {
			Integer.parseInt(firstWord);
			return true;
		}
		return false;
	}

	/**
	 * 
	 * @param parsedTime
	 */
	public void arrangeTimeList() {
		if (timeList != null && !timeList.isEmpty() && dateList != null) {
			if (timeList.size() < dateList.size() && hasRangeKeyword) {
				timeList.add(ParserConstants.FIRST_INDEX, LocalTime.MAX);
				taskDetails = cleanupExtraWhitespace(
						taskDetails.substring(ParserConstants.FIRST_INDEX, rangeKeywordStartPos)
								+ taskDetails.substring(rangeKeywordEndPos));
			}
		}
	}

	public void addValidTimeToList(LocalTime parsedTime) {
		timeList.add(parsedTime);
	}

	public LocalTime getTimeNow() {
		return LocalTime.now().truncatedTo(ChronoUnit.MINUTES);
	}

	public boolean isValidKeyWord(String keyword) {
		return hasInDictionary(ParserConstants.TIME_KEYWORD, keyword.trim());
	}

	/**
	 * This method checks if the given keyword is a range keyword and responds
	 * to the second time in the list.
	 * 
	 * @param keyword
	 * @return return true if keyword equals "to" or "-"; false otherwise.
	 */
	public boolean isValidRangeKeyWord(String keyword, int keywordEndPos, LocalTime currentParsedTime) {
		if (isRangeKeyWord(keyword)) {
			if (timeList.size() > ParserConstants.MIN_SIZE) {
				return true;
			}
			rangeKeywordStartPos = taskDetails.lastIndexOf(keyword, keywordEndPos);
			if (addToListIfMissedTime(rangeKeywordStartPos, currentParsedTime)) {
				return true;
			}
			hasRangeKeyword = true;
			rangeKeywordEndPos = rangeKeywordStartPos + keyword.length();
		}
		return false;
		/*
		 * return (keyword.equalsIgnoreCase(ParserConstants.STRING_HYPHEN) ||
		 * keyword.equalsIgnoreCase(ParserConstants.STRING_TO)) &&
		 * (timeList.size() > ParserConstants.MIN_SIZE) ;
		 */
	}

	/**
	 * "to" and hyphen "-" are the range keywords. This method checks if keyword
	 * is a valid range keyword.
	 * 
	 * @param keyword
	 * @return return true if keyword equals "to" or "-"; false otherwise.
	 */
	public boolean isRangeKeyWord(String keyword) {
		keyword = keyword.trim();
		return (keyword.equalsIgnoreCase(ParserConstants.STRING_HYPHEN)
				|| keyword.equalsIgnoreCase(ParserConstants.STRING_TO));
	}

	/**
	 * A missed time is a 12-hr time format without am pm specified to it
	 * preceding a range keyword. This method finds out the missed time and add
	 * it to the timeList.
	 * 
	 * @param endPos
	 * @param currentParsedTime
	 * @return true if missedTime detected; otherwise false.
	 */
	public boolean addToListIfMissedTime(int endPos, LocalTime currentParsedTime) {
		String previousWord = getLastWordInRange(taskDetails, endPos);
		try {
			int missedTime = Integer.parseInt(previousWord);
			LocalTime timeAM = getMissedTime(missedTime);
			if (timeAM != null) {
				timeList.add(ParserConstants.FIRST_INDEX, calculateMissed(timeAM, currentParsedTime));
				removeTimeFromTaskDetails(previousWord);
				return true;
			}
		} catch (NumberFormatException nfe) {
			return false;
		}
		return false;
	}

	/**
	 * A missed time is a 12-hr time format without am pm specified to it
	 * preceding a range keyword. This method helps retrieve the missed time but
	 * in AM format only.
	 * 
	 * @param time
	 * @return the missed time in AM
	 */
	public LocalTime getMissedTime(int time) {
		if (time > ParserConstants.FIRST_INDEX) {
			int mins = ParserConstants.FIRST_INDEX;
			int hrs = ParserConstants.FIRST_INDEX;
			if (time <= ParserConstants.TWELVE_HOURS) {
				return LocalTime.of(time, mins);
			}
			mins = time % 100;
			hrs = time / 100;
			if (hrs > ParserConstants.FIRST_INDEX && hrs <= ParserConstants.TWELVE_HOURS
					&& mins <= ParserConstants.MAX_MINUTES) {
				return LocalTime.of(hrs, mins);
			}
		}
		return null;
	}

	/**
	 * A missed time is a 12-hr time format without am pm specified to it. This
	 * method helps determine if the missed time is am or pm.
	 * 
	 * @param missedTime
	 * @param currentParsedTime
	 * @return the 24hr converted format of the input 12 hr time input
	 */
	public LocalTime calculateMissed(LocalTime missedTime, LocalTime currentParsedTime) {
		if (missedTime.plusHours(ParserConstants.TWELVE_HOURS).isBefore(currentParsedTime)) {
			return missedTime.plusHours(ParserConstants.TWELVE_HOURS);
		}
		return missedTime;
	}

	public void formatHyphenDelimiter() {
		String taskDetails = getTaskDetails();
		Pattern hyphenPattern = Pattern.compile(ParserConstants.REGEX_HYPHEN_WITH_DIGITS);
		Matcher hyphenMatcher = hyphenPattern.matcher(taskDetails);
		while (hyphenMatcher.find()) {
			String split1 = taskDetails.substring(0, hyphenMatcher.start());
			String split2 = taskDetails.substring(hyphenMatcher.start()).replaceFirst(ParserConstants.STRING_HYPHEN,
					ParserConstants.STRING_HYPHEN_WHITESPACE);
			taskDetails = split1 + split2;
		}
		setTaskDetails(taskDetails);
	}

	/**
	 * A valid end is denoted by a String that ends with a period, comma,
	 * whitespace or is the end of the String.
	 * 
	 * @param endText
	 *            to check if its end is valid.
	 * @return true if endText has valid end; false otherwise.
	 */
	private boolean isValidEnd(String endText) {
		if (endText.isEmpty()) {
			return true;
		}
		String firstCharacter = endText.charAt(ParserConstants.FIRST_INDEX) + ParserConstants.STRING_EMPTY;
		return hasInDictionary(ParserConstants.VALID_END, firstCharacter);
	}

	/**
	 * This method is used to find the end of the String text from the first
	 * occurrence of a non-word character.
	 * 
	 * @param text
	 * @return substring of text, starting from first non-word character until
	 *         the end of text. If no non-word character present, returns an
	 *         empty String.
	 */
	private String getEnd(String text) {
		int indexOfNonWord = getIndexOfNonWordChar(text);
		if (indexOfNonWord > ParserConstants.DEFAULT_INDEX_NUMBER) {
			return text.substring(indexOfNonWord);
		}
		return ParserConstants.STRING_EMPTY;
	}

	/**
	 * This method substring text, until the first occurrence of a non-word
	 * character.
	 * 
	 * @param text
	 * @return substring of text from index 0 until the first occurrence of
	 *         non-word character.
	 */
	private String getStartString(String text) {
		int indexOfNonWord = getIndexOfNonWordChar(text);
		if (indexOfNonWord > ParserConstants.DEFAULT_INDEX_NUMBER) {
			return text.substring(ParserConstants.FIRST_INDEX, indexOfNonWord);
		}
		return text;
	}

	/**
	 * This method returns the first 'x' words from the given wordToSplit.
	 * 
	 * @param wordToSplit
	 * @param x,
	 *            number of words to return
	 * @return first x words from wordToSplit, if present; otherwise null.
	 */
	public String getFirstXWords(String wordToSplit, int x) {

		if (wordToSplit != null && !wordToSplit.isEmpty() && x > 0) {
			String[] words = wordToSplit.split(ParserConstants.STRING_WHITESPACE);

			if (words.length >= x) {
				String firstXWords = ParserConstants.STRING_EMPTY;
				for (int index = ParserConstants.FIRST_INDEX; index < x; index++) {
					firstXWords += ParserConstants.STRING_WHITESPACE + words[index];
				}
				return cleanupExtraWhitespace(firstXWords);
			}
		}

		return null;
	}

	/**
	 * This method is used to determine the last word in text between 0 and
	 * endIndex.
	 * 
	 * @param text
	 * @param endIndex
	 * @return last word of text in the range [0, endIndex] if present;
	 *         otherwise empty String.
	 */
	public String getLastWordInRange(String text, int endIndex) {

		if (text != null && !text.isEmpty() && endIndex > 0) {
			text = text.substring(ParserConstants.FIRST_INDEX, endIndex);
			String[] words = text.split(ParserConstants.STRING_WHITESPACE);
			return words[words.length - 1];
		}
		return ParserConstants.STRING_EMPTY;
	}

	/**
	 * This method returns the first occurrence of word in array[].
	 * 
	 * @param word
	 * @param array
	 * @return return the first index of word if it is present in array[];
	 *         otherwise -1.
	 */
	public int indexOf(String word, String[] array) {
		if (hasInDictionary(array, word)) {
			for (int index = ParserConstants.FIRST_INDEX; index < array.length; index++) {
				if (word.equalsIgnoreCase(array[index])) {
					return index;
				}
			}
		}
		return ParserConstants.DEFAULT_INDEX_NUMBER; // if absent
	}

	/**
	 * This method detects the index of a non-word character in the String word.
	 * A non-word character includes everything other than an English letter, a
	 * digit and a whitespace.
	 * 
	 * @param word
	 *            is checked for any non-word character.
	 * @return index, of first non-word character in word.
	 */
	public int getIndexOfNonWordChar(String word) {
		int index = ParserConstants.DEFAULT_INDEX_NUMBER;

		if (word != null) {

			for (index = ParserConstants.FIRST_INDEX; index < word.length(); index++) {
				if (!Character.isLetterOrDigit(word.charAt(index)) && !Character.isWhitespace(word.charAt(index))) {
					break;
				}
			}

			if (index == word.length()) {
				return ParserConstants.DEFAULT_INDEX_NUMBER;
			}
		}
		return index;
	}

	public boolean taskDetailsContains(String text) {
		Pattern containPattern = Pattern.compile(ParserConstants.REGEX_VALID_START + text);
		Matcher containMatcher = containPattern.matcher(taskDetails);
		if (containMatcher.find()) {
			return true;
		}
		return false;
	}

	/**
	 * This method checks if any index of dictionary[] equals the wordsToFind
	 * (case insensitive).
	 * 
	 * @param dictionary
	 * @param wordsToFind
	 * @return true if dictionary contains wordToFind; false otherwise.
	 */
	private boolean hasInDictionary(String[] dictionary, String wordToFind) {
		if (wordToFind != null && !wordToFind.isEmpty()) {
			for (String dictionaryWords : dictionary) {
				if (dictionaryWords.equalsIgnoreCase(wordToFind))
					return true;
			}
		}
		return false;
	}

	/**
	 * This method removes the unnecessary white spaces present in the string.
	 * 
	 * @param someText
	 *            is any string with several white spaces.
	 * @return someText excluding the extra unnecessary white spaces.
	 */
	public String cleanupExtraWhitespace(String someText) {
		Pattern extraSpace = Pattern.compile(ParserConstants.REGEX_EXTRA_WHITESPACE);
		Matcher regexMatcher = extraSpace.matcher(someText.trim());
		String cleanText = regexMatcher.replaceAll(ParserConstants.STRING_WHITESPACE);
		return cleanText;
	}

	/**
	 * This method returns an array list of possible time formats
	 * 
	 * @return dateFormatList, contains all acceptable time formats in
	 *         DateTimeFormatter type ArrayList
	 * 
	 */
	public static ArrayList<DateTimeFormatter> generateTimeFormatList() {
		ArrayList<DateTimeFormatter> dateFormatList = new ArrayList<DateTimeFormatter>();
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_MIN_AMPM_WITHOUT_SPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_MIN_AMPM_WITH_SPACE));
		dateFormatList.add(
				DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_MIN_AMPM_WITH_PERIOD_WITHOUT_SPACE));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_MIN_AMPM_WITH_PERIOD_WITH_SPACE));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_MIN_AMPM_WITH_COLOM_WITHOUT_SPACE));
		dateFormatList
				.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_MIN_AMPM_WITH_COLON_WITH_SPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_AMPM_WITHOUT_SPACE));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_12HOUR_AMPM_WITH_SPACE));

		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_24HOUR_MIN));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_24HOUR_COLON));
		dateFormatList.add(DateTimeFormatter.ofPattern(ParserConstants.TIME_FORMAT_24HOUR_PERIOD));
		return dateFormatList;
	}
}
```
###### \Parser\TimeParserTest.java
``` java

package Parser;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

import java.time.LocalTime;
import java.time.temporal.ChronoUnit;

public class TimeParserTest {

	TimeParser timeObj = new TimeParser();

	@Test
	public void testAddToListIfValidTime1() {
		String testString = "13.30 at Starbucks";
		String output = "";
		timeObj = new TimeParser(testString);
		timeObj.findTimes();
		for (LocalTime time : timeObj.getTimeList()) {
			output += time.toString();
		}
		String expected = "13:30";
		assertEquals(expected, output);
		assertEquals("at Starbucks", timeObj.getTaskDetails());
	}

	@Test
	public void testAddToListIfValidTime2() {
		String testString = "Meet Jim at 230pm";
		String output = "";
		timeObj = new TimeParser(testString);
		timeObj.findTimes();
		for (LocalTime time : timeObj.getTimeList()) {
			output += time.toString();
		}
		String expectedTime = "14:30";
		assertEquals(expectedTime, output);
		assertEquals("Meet Jim", timeObj.getTaskDetails());
	}

	@Test
	public void testAddToListIfValidTime3() {
		String testString = "Meet Jim 230pm - 330am";
		String output = "";
		timeObj = new TimeParser(testString);
		timeObj.findTimes();
		for (LocalTime time : timeObj.getTimeList()) {
			output += time.toString();
		}
		String expectedTime = "14:3003:30";
		assertEquals(expectedTime, output);
		assertEquals("Meet Jim", timeObj.getTaskDetails());
	}

	@Test
	public void testAddToListIfValidTime4() {
		String testString = "Go to CS2103 Tutorial 9 am";
		String output = "";
		timeObj = new TimeParser(testString);
		timeObj.findTimes();
		for (LocalTime time : timeObj.getTimeList()) {
			output += time.toString();
		}
		String expectedTime = "09:00";
		assertEquals(expectedTime, output);
		assertEquals("Go to CS2103 Tutorial", timeObj.getTaskDetails());
	}

	@Test
	public void testFindTime1() {
		String testString = "Meet Darwin 3 hrs";
		String output = "";
		timeObj = new TimeParser(testString);
		timeObj.findTimes();

		if (timeObj.getTimeList() != null) {
			for (LocalTime time : timeObj.getTimeList()) {
				output += time.toString();
			}
		}
		assertEquals(LocalTime.now().plusHours(3).truncatedTo(ChronoUnit.MINUTES).toString(), output);
		assertEquals("Meet Darwin", timeObj.getTaskDetails());
	}

	@Test
	public void testFindTime2() {
		String testString = "Meet Darwin 3 - 5pm";
		String output = "";
		timeObj = new TimeParser(testString);
		timeObj.findTimes();

		if (timeObj.getTimeList() != null) {
			for (LocalTime time : timeObj.getTimeList()) {
				output += time.toString();
			}
		}
		assertEquals("15:0017:00", output);
		assertEquals("Meet Darwin", timeObj.getTaskDetails());
	}

	@Test
	public void testFindTime3() {
		String testString = "Meet Darwin 3 - 5am";
		String output = "";
		timeObj = new TimeParser(testString);
		timeObj.findTimes();

		if (timeObj.getTimeList() != null) {
			for (LocalTime time : timeObj.getTimeList()) {
				output += time.toString();
			}
		}
		assertEquals("03:0005:00", output);
		assertEquals("Meet Darwin", timeObj.getTaskDetails());
	}
}
```
###### \ScheduleHacks\Task.java
``` java

package ScheduleHacks;

import java.time.LocalDate;
import java.time.LocalTime;

/**
 * This is essentially an object class. It comprises of constructors, getter and
 * setter methods only. No significant computation is performed in this class.
 */
public class Task {

	private String description;
	private boolean isFloatingType, isScheduledType, isComplete;
	private LocalDate startDate, endDate;
	private LocalTime startTime, endTime;

	/****************** CONSTRUCTORS **********************/
	public Task() {
		setDescription(null);
		isFloatingType = false;
		isScheduledType = false;
		isComplete = false;
		setStartDate(null);
		setEndDate(null);
		setStartTime(null);
		setEndTime(null);
	}

	public Task(String desc, LocalDate startDate, LocalDate endDate, LocalTime startTime, LocalTime endTime) {
		setDescription(desc);
		isFloatingType = false;
		isScheduledType = false;
		isComplete = false;
		setStartDate(startDate);
		setEndDate(endDate);
		setStartTime(startTime);
		setEndTime(endTime);
	}

	public Task(Task oldTask) {
		setDescription(oldTask.getDescription());
		if (oldTask.isFloatingTask()) {
			setFloatingTask();
		}
		if (oldTask.isScheduledTask()) {
			setScheduledTask();
		}
		isComplete = oldTask.isComplete();
		setStartDate(oldTask.getStartDate());
		setEndDate(oldTask.getEndDate());
		setStartTime(oldTask.getStartTime());
		setEndTime(oldTask.getEndTime());
	}

	/****************** OTHER METHODS ***********************/
	public void setDescription(String description) {
		this.description = description;
	}

	public String getDescription() {
		return this.description;
	}

	public void setFloatingTask() {
		isFloatingType = true;
		isScheduledType = false;
	}

	public void setScheduledTask() {
		isFloatingType = false;
		isScheduledType = true;
	}

	public void setAsComplete() {
		isComplete = true;
	}

	public void setAsIncomplete() {
		isComplete = false;
	}

	public boolean isFloatingTask() {
		return isFloatingType;
	}

	public boolean isScheduledTask() {
		return isScheduledType;
	}

	public boolean isComplete() {
		return isComplete;
	}

	public void setStartDate(LocalDate startDate) {
		this.startDate = startDate;
	}

	public void setEndDate(LocalDate endDate) {
		this.endDate = endDate;
	}

	public LocalDate getStartDate() {
		return this.startDate;
	}

	public LocalDate getEndDate() {
		return this.endDate;
	}

	public void setStartTime(LocalTime startTime) {
		this.startTime = startTime;
	}

	public void setEndTime(LocalTime endTime) {
		this.endTime = endTime;
	}

	public LocalTime getStartTime() {
		return this.startTime;
	}

	public LocalTime getEndTime() {
		return this.endTime;
	}
}
```
###### \SHTestSuite.java
``` java

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

import Parser.*;
import Storage.*;
import ScheduleHacks.*;
import Logic.*;

@RunWith(Suite.class)
@Suite.SuiteClasses({
 
  LogicTest.class,
  CommandParserTest.class,
  DateParserTest.class,
  TimeParserTest.class,
  IndexParserTest.class,
  DateTimeParserTest.class,
  HistoryTest.class,
  StorageTest.class,
  IntegrationTest.class
  
})
public class SHTestSuite {   
}  		
```
